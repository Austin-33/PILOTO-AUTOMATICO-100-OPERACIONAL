
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import matplotlib.dates as mdates
from matplotlib.patches import Rectangle
import mplfinance as mpf
import tkinter as tk
from tkinter import ttk
import sqlite3
from datetime import datetime, timedelta
from selenium import webdriver
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.firefox import GeckoDriverManager
import time
import threading

# ------------------- IN√çCIO: L√ìGICA CRMA E AJUSTE DE CASHOUT -------------------

CRMA_PATTERNS = ["RXR", "ROXR", "ROXOR", "ROOXXOOR", "AR", "AXR", "AOXR", "AOXOR", "AOOXXOOR"]

CASH_OUTS = {
    "RXR": [2.0, 3.0],
    "ROXR": [2.2, 3.2],
    "ROXOR": [2.5, 3.5],
    "ROOXXOOR": [3.0, 4.0],
    "AR": [1.8, 2.8],
    "AXR": [2.0, 3.0],
    "AOXR": [2.2, 3.2],
    "AOXOR": [2.5, 3.5],
    "AOOXXOOR": [3.0, 4.0],
    "5th_house": [1.49, 1.9]
}

def map_history_to_pattern(history, pattern_len):
    """Mapeia os √∫ltimos valores do hist√≥rico para letras conforme as regras."""
    rec = []
    for x in history[-pattern_len:]:
        if x >= 10.0:
            rec.append("A")
        elif x >= 2.0:
            rec.append("R")
        else:
            rec.append("X")
    return "".join(rec)

def check_pattern_similarity(history, pattern):
    """Retorna True se o hist√≥rico recente corresponde ao padr√£o (>=50% de acerto)."""
    pattern_len = len(pattern)
    if len(history) < pattern_len:
        return False
    history_pattern = map_history_to_pattern(history, pattern_len)
    matches = sum(1 for h, p in zip(history_pattern, pattern) if h == p)
    return (matches / pattern_len) >= 0.5

def ajustar_cashout_automatico(cashout1, cashout2):
    try:
        # 1¬™ aposta
        auto_button_1 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_button_1))
        )
        auto_button_1.click()
        auto_switch_1 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_switch_1))
        )
        driver.execute_script("arguments[0].click();", auto_switch_1)
        auto_input_1 = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, auto_cashout_input_1))
        )
        auto_input_1.send_keys(Keys.CONTROL + "a")
        auto_input_1.send_keys(Keys.DELETE)
        auto_input_1.send_keys(str(cashout1))
        # 2¬™ aposta
        auto_button_2 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_button_2))
        )
        driver.execute_script("arguments[0].click();", auto_button_2)
        auto_switch_2 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_switch_2))
        )
        driver.execute_script("arguments[0].click();", auto_switch_2)
        auto_input_2 = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, auto_cashout_input_2))
        )
        auto_input_2.send_keys(Keys.CONTROL + "a")
        auto_input_2.send_keys(Keys.DELETE)
        auto_input_2.send_keys(str(cashout2))
        print(f"Cashouts ajustados: {cashout1} e {cashout2}")
    except Exception as e:
        print(f"Erro ao ajustar cashouts: {e}")

# ------------------- FIM: L√ìGICA CRMA E AJUSTE DE CASHOUT -------------------

# ... RESTANTE DO SEU C√ìDIGO INALTERADO AT√â A FUN√á√ÉO estrategia_principal() ...

# Substitua apenas a fun√ß√£o estrategia_principal por esta vers√£o:

def estrategia_principal():
    global casas_passadas, detectou_rosa, ultima_vela_rosa, martingale_count_1, martingale_count_2, ultimo_resultado, vitorias, derrotas, lucro_acumulado, perdas_acumuladas, saldo, rodadas, rodadas_apos_rosa

    configurar_cashout_automatico()
    padrao_ativo = None
    casas_em_padrao = 0

    while True:
        historico = pegar_historico_real()
        if not historico or len(historico) < 5:
            print("‚ö†Ô∏è Hist√≥rico insuficiente ou n√£o capturado")
            time.sleep(2)
            continue
        print(f"üìà Hist√≥rico atual: {historico}")
        rodadas = historico

        # 1. Se houver um padr√£o CRMA ativo, continue seguindo enquanto ele corresponder
        if padrao_ativo:
            if check_pattern_similarity(rodadas, padrao_ativo):
                cashouts = CASH_OUTS.get(padrao_ativo, CASH_OUTS["5th_house"])
                ajustar_cashout_automatico(*cashouts)
                print(f"üîé Padr√£o CRMA em andamento '{padrao_ativo}'. Continuando ca√ßada. Cashouts: {cashouts}")
                casas_em_padrao += 1
                # Aqui voc√™ pode chamar sua l√≥gica de aposta padr√£o, se desejar.
            else:
                print(f"‚ö†Ô∏è Padr√£o CRMA '{padrao_ativo}' QUEBROU antes do Rosa. Voltando a aguardar Rosa para ativar 5¬™ casa.")
                padrao_ativo = None
                casas_em_padrao = 0

        # 2. Se n√£o h√° padr√£o ativo, e estamos na 5¬™ casa ap√≥s Rosa, verifique os padr√µes CRMA antes de apostar
        if not padrao_ativo and detectou_rosa and casas_passadas == 4:
            padrao_encontrado = None
            for padrao in CRMA_PATTERNS:
                if check_pattern_similarity(rodadas, padrao):
                    padrao_encontrado = padrao
                    break
            if padrao_encontrado:
                padrao_ativo = padrao_encontrado
                casas_em_padrao = 1
                cashouts = CASH_OUTS[padrao_encontrado]
                ajustar_cashout_automatico(*cashouts)
                print(f"üîé Novo padr√£o CRMA detectado '{padrao_encontrado}'. Iniciando ca√ßa ao padr√£o. Cashouts: {cashouts}")
                # Aqui voc√™ pode chamar sua l√≥gica de aposta padr√£o, se desejar.
            else:
                # Nenhum padr√£o, segue normalmente para 5¬™ casa ap√≥s Rosa
                cashouts = CASH_OUTS["5th_house"]
                ajustar_cashout_automatico(*cashouts)
                print("üîé Nenhum padr√£o CRMA detectado. Usando cashouts padr√£o da 5¬™ casa.")
                # --- BLOCO DA 5¬™ CASA ORIGINAL ABAIXO ---
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                total_perda = 0.0
                try:
                    saldo_clean = saldo.replace('Kz', '').replace('AOA', '').replace(',', '.').strip()
                    saldo_float = float(saldo_clean)
                except:
                    saldo_float = 0.0
                aposta1 = None
                aposta2 = None
                if martingale_count_1 < limite_martingale:
                    aposta1 = apostar_com_base_na_banca(martingale_count_1, 1)
                if martingale_count_2 < limite_martingale:
                    aposta2 = apostar_com_base_na_banca(martingale_count_2, 2)
                if aposta1 is not None and aposta2 is not None:
                    print(f"üéØ {casas_passadas + 1}¬™ casa chegou! Fazendo entradas simult√¢neas...")

                    threads = []
                    t1 = threading.Thread(target=lambda: clicar_botao(botao1_xpath))
                    t2 = threading.Thread(target=lambda: clicar_botao(botao2_xpath))
                    threads.append(t1)
                    threads.append(t2)
                    t1.start()
                    t2.start()
                    for t in threads:
                        t.join()
                    time.sleep(5)
                    resultado1, multiplicador1 = verificar_resultado(aposta1, 1.49)
                    resultado2, multiplicador2 = verificar_resultado(aposta2, 1.90)
                    if aposta1 is not None:
                        if resultado1:
                            vitorias += 1
                            lucro = aposta1 * (1.49 - 1)
                            lucro_acumulado += lucro
                            ultimo_resultado = f"Vit√≥ria (+Kz {lucro:.2f})"
                            print(f"üèÜ Vit√≥ria na 1¬™ aposta! Lucro: Kz {lucro:.2f}.")
                            salvar_entrada(aposta1, martingale_count_1, "Vit√≥ria", lucro, multiplicador1)
                            martingale_count_1 = limite_martingale
                        else:
                            total_perda += aposta1
                            historico_martingale.append(f"1¬™ aposta (tentativa {martingale_count_1 + 1}): Falha - Kz {aposta1:.2f}")
                            print(f"‚ö° 1¬™ aposta falhou (tentativa {martingale_count_1 + 1}).")
                            martingale_count_1 += 1
                    if aposta2 is not None:
                        if resultado2:
                            vitorias += 1
                            lucro = aposta2 * (1.90 - 1)
                            lucro_acumulado += lucro
                            ultimo_resultado = f"Vit√≥ria (+Kz {lucro:.2f})"
                            print(f"üèÜ Vit√≥ria na 2¬™ aposta! Lucro: Kz {lucro:.2f}.")
                            salvar_entrada(aposta2, martingale_count_2, "Vit√≥ria", lucro, multiplicador2)
                            martingale_count_2 = limite_martingale
                        else:
                            total_perda += aposta2
                            historico_martingale.append(f"2¬™ aposta (tentativa {martingale_count_2 + 1}): Falha - Kz {aposta2:.2f}")
                            print(f"‚ö° 2¬™ aposta falhou (tentativa {martingale_count_2 + 1}).")
                            martingale_count_2 += 1
                    if martingale_count_1 >= limite_martingale and martingale_count_2 >= limite_martingale:
                        if total_perda > 0 and not (resultado1 and resultado2):
                            derrotas += 1
                            perdas_acumuladas += total_perda
                            ultimo_resultado = f"Derrota (-Kz {total_perda:.2f})"
                            print(f"üíÄ Derrota nas apostas ap√≥s todas as tentativas de MG. Perda total: Kz {total_perda:.2f}.")
                            mt_ref = max(martingale_count_1, martingale_count_2)
                            mult_ref = max(multiplicador1, multiplicador2) if multiplicador1 > 0 or multiplicador2 > 0 else 0
                            salvar_entrada(max(aposta1, aposta2) if aposta1 or aposta2 else 0, mt_ref, "Derrota", -total_perda, mult_ref)
                        resetar_estrategia()
                        apostar_com_base_na_banca(0, 1)
                        apostar_com_base_na_banca(0, 2)
                        continue

        time.sleep(1)

# ... RESTANTE DO SEU C√ìDIGO SEGUIDO NORMALMENTE ...

# Configura√ß√£o do Selenium
options = Options()
options.add_argument("--disable-logging")
options.add_argument("--start-maximized")
options.add_argument("--disable-blink-features=AutomationControlled")
options.set_preference("dom.webdriver.enabled", False)
options.set_preference("useAutomationExtension", False)

# Vari√°veis globais
iframe_externo = None
iframe_interno = None
driver = None
casas_passadas = 0
detectou_rosa = False
ultima_vela_rosa = 0.0
martingale_count_1 = 0
martingale_count_2 = 0
limite_martingale = 2
base_bet_percentage_1 = 0.02  # 2% para a 1¬™ aposta
base_bet_percentage_2 = 0.01  # 1% para a 2¬™ aposta
vitorias = 0
derrotas = 0
lucro_acumulado = 0.0
perdas_acumuladas = 0.0
ultimo_resultado = "N/A"
historico_entradas = []
saldo = "N/A"
rodadas = []
rodadas_apos_rosa = []
historico_martingale = []
ultimo_multiplicador_processado = None

# XPaths dos bot√µes e elementos
botao1_xpath = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[1]/div[2]/div[2]/button"
botao2_xpath = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[1]/div[3]/div[2]/button"
cashout_xpath = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[1]/div[3]/div[2]/button"

# XPaths para cashout autom√°tico
auto_cashout_button_1 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[1]/div[1]/app-navigation-switcher/div/button[2]"
auto_cashout_switch_1 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[3]/div/div[2]/div[1]/app-ui-switcher/div"
auto_cashout_input_1 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[3]/div/div[2]/div[2]/div/app-spinner/div/div[2]/input"

auto_cashout_button_2 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[1]/div[2]/app-navigation-switcher/div/button[2]"
auto_cashout_switch_2 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[3]/div/div[2]/div[1]/app-ui-switcher/div"
auto_cashout_input_2 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[3]/div/div[2]/div[2]/div/app-spinner/div/div[2]/input"

# Banco de dados
def conectar():
    return sqlite3.connect("historico_aviator.db")

def criar_tabelas():
    conn = conectar()
    cursor = conn.cursor()
    cursor.execute("DROP TABLE IF EXISTS rodadas")
    cursor.execute(""" 
        CREATE TABLE rodadas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            multiplicador FLOAT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    """)
    cursor.execute("DROP TABLE IF EXISTS entradas")
    cursor.execute(""" 
        CREATE TABLE entradas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            aposta FLOAT,
            martingale INTEGER,
            outcome TEXT,
            profit_loss FLOAT,
            multiplicador FLOAT
        )
    """)
    conn.commit()
    conn.close()

criar_tabelas()

def salvar_rodada(multiplicador):
    conn = conectar()
    cursor = conn.cursor()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute("INSERT INTO rodadas (multiplicador, timestamp) VALUES (?, ?)", (multiplicador, timestamp))
    conn.commit()
    conn.close()

def salvar_entrada(aposta, martingale, outcome, profit_loss, multiplicador):
    conn = conectar()
    cursor = conn.cursor()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute(
        "INSERT INTO entradas (timestamp, aposta, martingale, outcome, profit_loss, multiplicador) VALUES (?, ?, ?, ?, ?, ?)",
        (timestamp, aposta, martingale, outcome, profit_loss, multiplicador)
    )
    conn.commit()
    conn.close()
    exportar_historico_excel()
    atualizar_tabela_historico(timestamp, aposta, martingale, outcome, profit_loss, multiplicador)

def exportar_historico_excel():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("SELECT timestamp, aposta, martingale, outcome, profit_loss, multiplicador FROM entradas ORDER BY timestamp DESC")
        entradas = cursor.fetchall()
        conn.close()

        df = pd.DataFrame(entradas, columns=["Timestamp", "Aposta", "Martingale", "Outcome", "Profit_Loss", "Multiplicador"])
        df["Aposta"] = df["Aposta"].apply(lambda x: f"Kz {x:.2f}")
        df["Profit_Loss"] = df["Profit_Loss"].apply(lambda x: f"{'+' if x >= 0 else ''}Kz {abs(x):.2f}")
        df["Multiplicador"] = df["Multiplicador"].apply(lambda x: f"{x:.2f}x")
        df["Martingale"] = df["Martingale"].apply(lambda x: f"{x} ({'Base' if x == 0 else 'x' + str(2**x)})")

        now = datetime.now()
        data_diaria = now.strftime("%Y-%m-%d")
        df_diario = df[df["Timestamp"].str.startswith(data_diaria)]
        df_diario.to_excel(f"historico_diario_{data_diaria}.xlsx", index=False)

        inicio_semana = now - timedelta(days=now.weekday())
        fim_semana = inicio_semana + timedelta(days=6)
        semana_str = f"{inicio_semana.strftime('%Y-%m-%d')}_a_{fim_semana.strftime('%Y-%m-%d')}"
        df_semanal = df[(df["Timestamp"] >= inicio_semana.strftime("%Y-%m-%d")) & (df["Timestamp"] <= fim_semana.strftime("%Y-%m-%d"))]
        df_semanal.to_excel(f"historico_semanal_{semana_str}.xlsx", index=False)

        mes_str = now.strftime("%Y-%m")
        df_mensal = df[df["Timestamp"].str.startswith(mes_str)]
        df_mensal.to_excel(f"historico_mensal_{mes_str}.xlsx", index=False)

        print(f"üìä Hist√≥rico exportado para Excel: Di√°rio ({data_diaria}), Semanal ({semana_str}), Mensal ({mes_str})")
    except Exception as e:
        print(f"‚ùå Erro ao exportar hist√≥rico para Excel: {e}")

def obter_ultimas_rodadas(n=20):
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("SELECT multiplicador FROM rodadas ORDER BY timestamp DESC LIMIT ?", (n,))
        dados = [row[0] for row in cursor.fetchall()]
        conn.close()
        return dados
    except Exception as e:
        print(f"‚ùå Erro ao obter √∫ltimas rodadas: {e}")
        return []

def obter_estatisticas(periodo):
    try:
        conn = conectar()
        cursor = conn.cursor()
        now = datetime.now()
        if periodo == "Di√°rio":
            start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        elif periodo == "Semanal":
            start = now - timedelta(days=now.weekday())
            start = start.replace(hour=0, minute=0, second=0, microsecond=0)
        elif periodo == "Mensal":
            start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        else:
            start = now.replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)

        cursor.execute("""
            SELECT outcome, profit_loss 
            FROM entradas 
            WHERE timestamp >= ?
        """, (start.strftime("%Y-%m-%d %H:%M:%S"),))

        vitorias = 0
        derrotas = 0
        lucro = 0.0
        perdas = 0.0

        for row in cursor.fetchall():
            outcome, profit_loss = row
            if outcome == "Vit√≥ria":
                vitorias += 1
                lucro += profit_loss
            elif outcome == "Derrota":
                derrotas += 1
                perdas += abs(profit_loss)

        conn.close()
        return vitorias, derrotas, lucro, perdas
    except Exception as e:
        print(f"‚ùå Erro ao obter estat√≠sticas para {periodo}: {e}")
        return 0, 0, 0.0, 0.0

def obter_entradas_historico():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("SELECT timestamp, aposta, martingale, outcome, profit_loss, multiplicador FROM entradas ORDER BY timestamp DESC LIMIT 100")
        entradas = [
            {
                "timestamp": row[0],
                "aposta": row[1],
                "martingale": row[2],
                "outcome": row[3],
                "profit_loss": row[4],
                "multiplicador": row[5]
            }
            for row in cursor.fetchall()
        ]
        conn.close()
        return entradas
    except Exception as e:
        print(f"‚ùå Erro ao obter hist√≥rico de entradas: {e}")
        return []

def obter_saldo():
    global driver, iframe_externo, iframe_interno
    try:
        driver.switch_to.default_content()
        saldo_element = WebDriverWait(driver, 20).until(
            EC.presence_of_element_located((By.XPATH, '//span[contains(@class, "balance") or contains(text(), "Kz")]'))
        )
        saldo = saldo_element.text.strip()
        print(f"Saldo capturado: {saldo}")
        driver.switch_to.frame(iframe_externo)
        driver.switch_to.frame(iframe_interno)
        return saldo
    except Exception as e:
        print(f"Erro ao obter saldo: {e}")
        try:
            saldo_element = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, '//header//span[contains(text(), "Kz")]'))
            )
            saldo = saldo_element.text.strip()
            print(f"Saldo capturado (fallback): {saldo}")
            driver.switch_to.frame(iframe_externo)
            driver.switch_to.frame(iframe_interno)
            return saldo
        except Exception as e2:
            print(f"Erro no fallback: {e2}")
            driver.switch_to.frame(iframe_externo)
            driver.switch_to.frame(iframe_interno)
            return "N/A"

def generate_ohlc(data, group_size=5):
    ohlc_data = []
    num_groups = len(data) // group_size
    for i in range(num_groups):
        chunk = data[i*group_size:(i+1)*group_size]
        open_ = chunk[0]
        high = max(chunk)
        low = min(chunk)
        close = chunk[-1]
        ohlc_data.append((open_, high, low, close))
    return ohlc_data

def on_mouse_wheel(event, ax, canvas):
    if not ax:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    xlim = ax.get_xlim()
    ylim = ax.get_ylim()
    zoom_factor = 1.2 if event.delta > 0 else 1 / 1.2
    new_xlim = [x - (x - xlim[0]) * zoom_factor, x + (xlim[1] - x) * zoom_factor]
    new_ylim = [y - (y - ylim[0]) * zoom_factor, y + (ylim[1] - y) * zoom_factor]
    ax.set_xlim(new_xlim)
    ax.set_ylim(new_ylim)
    canvas.draw_idle()

def analisar_tendencia(rodadas, window=5):
    if len(rodadas) < window * 2:
        return "Insuficiente", "gray"

    medias = []
    for i in range(0, len(rodadas) - window + 1, window):
        bloco = rodadas[i:i + window]
        if len(bloco) == window:
            medias.append(sum(bloco) / window)

    if len(medias) < 2:
        return "Insuficiente", "gray"

    ultima_media = medias[-1]
    penultima_media = medias[-2]
    margem = 0.5

    if ultima_media > penultima_media + margem:
        return "Alta", "green"
    elif ultima_media < penultima_media - margem:
        return "Baixa", "red"
    else:
        return "Lateral", "yellow"

def analisar_velas_rosa(rodadas):
    if not rodadas:
        return "Nenhuma vela rosa", len(rodadas), "Baixa"

    indices_rosa = [i for i, x in enumerate(rodadas) if x >= 10.0]

    if not indices_rosa:
        return "Nenhuma vela rosa", len(rodadas), "Baixa"

    intervalos = []
    for i in range(1, len(indices_rosa)):
        intervalos.append(indices_rosa[i] - indices_rosa[i-1])

    intervalo_medio = sum(intervalos) / len(intervalos) if intervalos else len(rodadas)
    ultima_rosa = indices_rosa[0]
    distancia = ultima_rosa

    if distancia >= intervalo_medio:
        probabilidade = "Alta"
    elif distancia >= intervalo_medio * 0.5:
        probabilidade = "M√©dia"
    else:
        probabilidade = "Baixa"

    return f"{distancia} rodadas atr√°s", intervalo_medio, probabilidade

def mostrar_grafico_detetive(canvas_frame, rodadas):
    for widget in canvas_frame.winfo_children():
        widget.destroy()
    if not rodadas or len(rodadas) < 5:
        label = tk.Label(canvas_frame, text="Aguardando mais rodadas para exibir o gr√°fico...", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    ohlc_data = generate_ohlc(rodadas)
    if not ohlc_data:
        label = tk.Label(canvas_frame, text="Sem dados suficientes para o gr√°fico.", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    fig, ax = plt.subplots(figsize=(8, 4))
    width = 0.4
    for i, (open_, high, low, close) in enumerate(ohlc_data):
        cor = 'green' if close >= open_ else 'red'
        ax.plot([i, i], [low, high], color='black', linewidth=1)
        ax.add_patch(Rectangle((i - width/2, min(open_, close)), width, abs(close - open_), color=cor))
        grupo = rodadas[i*5:(i+1)*5]
        voos_str = ", ".join([f"{v:.2f}" for v in grupo])
        ax.text(i + 0.1, high + 0.5, voos_str, fontsize=8, rotation=45, color='blue')
    ax.set_xticks(range(len(ohlc_data)))
    ax.set_title("Modo Detetive - Gr√°fico Candlestick com Multiplicadores")
    ax.set_xlabel("Grupo de Rodadas")
    ax.set_ylabel("Multiplicador (x)")
    ax.grid(True)
    canvas = FigureCanvasTkAgg(fig, master=canvas_frame)
    canvas.draw()
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
    toolbar = NavigationToolbar2Tk(canvas, canvas_frame)
    toolbar.update()
    toolbar.pack(side=tk.BOTTOM, fill=tk.X)
    def mouse_wheel_event(event):
        on_mouse_wheel(event, ax, canvas)
    canvas.mpl_connect('scroll_event', mouse_wheel_event)

def mostrar_grafico_analista(canvas_frame, rodadas):
    for widget in canvas_frame.winfo_children():
        widget.destroy()
    if not rodadas or len(rodadas) < 5:
        label = tk.Label(canvas_frame, text="Aguardando mais rodadas para exibir o gr√°fico...", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    ohlc_data = generate_ohlc(rodadas)
    if not ohlc_data:
        label = tk.Label(canvas_frame, text="Sem dados suficientes para o gr√°fico.", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    dates = pd.date_range('2025-01-01', periods=len(ohlc_data))
    df = pd.DataFrame(ohlc_data, columns=["Open", "High", "Low", "Close"], index=dates)
    mc = mpf.make_marketcolors(up='green', down='red', inherit=True)
    s = mpf.make_mpf_style(marketcolors=mc)
    fig = plt.figure(figsize=(8, 4))
    ax = fig.add_subplot(111)
    mpf.plot(df, type='candle', style=s, title="Modo Analista - Gr√°fico Candlestick", ylabel='Multiplicador (x)', ax=ax, returnfig=True)
    canvas = FigureCanvasTkAgg(fig, master=canvas_frame)
    canvas.draw()
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
    toolbar = NavigationToolbar2Tk(canvas, canvas_frame)
    toolbar.update()
    toolbar.pack(side=tk.BOTTOM, fill=tk.X)
    def mouse_wheel_event(event):
        on_mouse_wheel(event, ax, canvas)
    canvas.mpl_connect('scroll_event', mouse_wheel_event)

def update_stats(period, frame, stats_label):
    try:
        if period not in ["Di√°rio", "Semanal", "Mensal", "Anual"]:
            print(f"‚ö†Ô∏è Per√≠odo inv√°lido: {period}")
            return
        vitorias, derrotas, lucro, perdas = obter_estatisticas(period)
        lucro = float(lucro) if lucro is not None else 0.0
        perdas = float(perdas) if perdas is not None else 0.0
        if stats_label and hasattr(stats_label, 'config'):
            stats_label.config(text=f"Ganhos: {vitorias} | Perdas: {derrotas} | Lucro: Kz {lucro:.2f} | Perdas: Kz {perdas:.2f}")
        else:
            print(f"‚ö†Ô∏è stats_label inv√°lido para per√≠odo {period}")
    except Exception as e:
        print(f"‚ùå Erro ao atualizar estat√≠sticas para {period}: {e}")

def configurar_navegacao():
    global iframe_externo, iframe_interno, driver
    print("üì¢ Iniciando configura√ß√£o de navega√ß√£o...")

    try:
        # Inicializar o WebDriver
        gecko_path = GeckoDriverManager().install()
        print(f"‚úÖ geckodriver instalado em: {gecko_path}")
        webdriver_service = Service(gecko_path, log_path="geckodriver.log")
        driver = webdriver.Firefox(service=webdriver_service, options=options)
        driver.implicitly_wait(10)
        print("‚úÖ Firefox WebDriver iniciado com sucesso")

        # Acessar a p√°gina inicial
        print("üì¢ Navegando para o site...")
        driver.get("https://www.bantubet.co.ao/pt/games")
        time.sleep(15)
        driver.refresh()
        print("‚úÖ P√°gina inicial carregada e atualizada.")

        # Aguardar e clicar no bot√£o de login
        print("üì¢ Aguardando bot√£o de login...")
        login_button = WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "#root > div.layout-header-holder-bc > header > div.hdr-main-content-bc > div.hdr-user-bc > button.btn.s-small.sign-in"))
        )
        time.sleep(5)
        login_button.click()
        print("‚úÖ Bot√£o de login clicado.")

        # Preencher campos de login
        print("üì¢ Preenchendo campos de login...")
        phone_input = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="root"]/div[6]/div/div/div/div/div/div[2]/form/div[1]/div[3]/div/label/input'))
        )
        phone_input.send_keys("923630632")
        time.sleep(2)
        password_input = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="root"]/div[6]/div/div/div/div/div/div[2]/form/div[1]/div[4]/div/label/input'))
        )
        password_input.send_keys("Ag9327777771317")
        time.sleep(4)
        submit_button = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="root"]/div[6]/div/div/div/div/div/div[2]/form/div[1]/div[6]/div/button'))
        )
        submit_button.click()
        print("üì¢ Login enviado, aguardando redirecionamento...")
        time.sleep(10)

        # Verificar login
        try:
            WebDriverWait(driver, 30).until(
                EC.presence_of_element_located((By.XPATH, '//span[contains(@class, "balance") or contains(text(), "Kz")]'))
            )
            print("‚úÖ Login bem-sucedido! Saldo vis√≠vel.")
        except Exception as e:
            print(f"‚ùå Falha ao verificar login: {e}")
            raise Exception("Login n√£o foi bem-sucedido. Verifique as credenciais ou a p√°gina de login.")

        # Acessar a p√°gina do jogo Aviator
        print("üì¢ Acessando p√°gina do jogo Aviator...")
        driver.get("https://www.bantubet.co.ao/pt/games?openGames=806666-real&gameNames=Aviator")
        time.sleep(15)

        # Localizar iframe externo
        print("üì¢ Localizando iframe externo...")
        iframe_externo = WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="root"]/div[3]/div[1]/div[1]/div/iframe'))
        )
        driver.switch_to.frame(iframe_externo)
        print("‚úÖ Iframe externo encontrado e acessado.")
        time.sleep(10)

        # Localizar iframe interno
        print("üì¢ Localizando iframe interno...")
        iframe_interno = WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="gameFrame"]'))
        )
        driver.switch_to.frame(iframe_interno)
        print("‚úÖ Iframe interno encontrado e acessado.")
        time.sleep(10)

        # Verificar se o jogo carregou
        try:
            WebDriverWait(driver, 30).until(
                EC.presence_of_element_located((By.CLASS_NAME, 'result-history'))
            )
            print("‚úÖ Jogo Aviator carregado com sucesso. Hist√≥rico vis√≠vel.")
    