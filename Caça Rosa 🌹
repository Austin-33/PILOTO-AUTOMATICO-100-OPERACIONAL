
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import matplotlib.dates as mdates
from matplotlib.patches import Rectangle
import mplfinance as mpf
import tkinter as tk
from tkinter import ttk
import sqlite3
from datetime import datetime, timedelta
from selenium import webdriver
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.firefox import GeckoDriverManager
import time
import threading

# ------------------- IN√çCIO: L√ìGICA CRMA E AJUSTE DE CASHOUT -------------------

CRMA_PATTERNS = ["RXR", "ROXR", "ROXOR", "ROOXXOOR", "AR", "AXR", "AOXR", "AOXOR", "AOOXXOOR"]

CASH_OUTS = {
    "RXR": [2.0, 3.0],
    "ROXR": [2.2, 3.2],
    "ROXOR": [2.5, 3.5],
    "ROOXXOOR": [3.0, 4.0],
    "AR": [1.8, 2.8],
    "AXR": [2.0, 3.0],
    "AOXR": [2.2, 3.2],
    "AOXOR": [2.5, 3.5],
    "AOOXXOOR": [3.0, 4.0],
    "5th_house": [1.49, 1.9]
}

def map_history_to_pattern(history, pattern_len):
    """Mapeia os √∫ltimos valores do hist√≥rico para letras conforme as regras."""
    rec = []
    for x in history[-pattern_len:]:
        if x >= 10.0:
            rec.append("A")
        elif x >= 2.0:
            rec.append("R")
        else:
            rec.append("X")
    return "".join(rec)

def check_pattern_similarity(history, pattern):
    """Retorna True se o hist√≥rico recente corresponde ao padr√£o (>=50% de acerto)."""
    pattern_len = len(pattern)
    if len(history) < pattern_len:
        return False
    history_pattern = map_history_to_pattern(history, pattern_len)
    matches = sum(1 for h, p in zip(history_pattern, pattern) if h == p)
    return (matches / pattern_len) >= 0.5

def ajustar_cashout_automatico(cashout1, cashout2):
    try:
        # 1¬™ aposta
        auto_button_1 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_button_1))
        )
        auto_button_1.click()
        auto_switch_1 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_switch_1))
        )
        driver.execute_script("arguments[0].click();", auto_switch_1)
        auto_input_1 = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, auto_cashout_input_1))
        )
        auto_input_1.send_keys(Keys.CONTROL + "a")
        auto_input_1.send_keys(Keys.DELETE)
        auto_input_1.send_keys(str(cashout1))
        # 2¬™ aposta
        auto_button_2 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_button_2))
        )
        driver.execute_script("arguments[0].click();", auto_button_2)
        auto_switch_2 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_switch_2))
        )
        driver.execute_script("arguments[0].click();", auto_switch_2)
        auto_input_2 = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, auto_cashout_input_2))
        )
        auto_input_2.send_keys(Keys.CONTROL + "a")
        auto_input_2.send_keys(Keys.DELETE)
        auto_input_2.send_keys(str(cashout2))
        print(f"Cashouts ajustados: {cashout1} e {cashout2}")
    except Exception as e:
        print(f"Erro ao ajustar cashouts: {e}")

# ------------------- FIM: L√ìGICA CRMA E AJUSTE DE CASHOUT -------------------

# ... RESTANTE DO SEU C√ìDIGO INALTERADO AT√â A FUN√á√ÉO estrategia_principal() ...

# Substitua apenas a fun√ß√£o estrategia_principal por esta vers√£o:

def estrategia_principal():
    global casas_passadas, detectou_rosa, ultima_vela_rosa, martingale_count_1, martingale_count_2, ultimo_resultado, vitorias, derrotas, lucro_acumulado, perdas_acumuladas, saldo, rodadas, rodadas_apos_rosa

    configurar_cashout_automatico()
    padrao_ativo = None
    casas_em_padrao = 0

    while True:
        historico = pegar_historico_real()
        if not historico or len(historico) < 5:
            print("‚ö†Ô∏è Hist√≥rico insuficiente ou n√£o capturado")
            time.sleep(2)
            continue
        print(f"üìà Hist√≥rico atual: {historico}")
        rodadas = historico

        # 1. Se houver um padr√£o CRMA ativo, continue seguindo enquanto ele corresponder
        if padrao_ativo:
            if check_pattern_similarity(rodadas, padrao_ativo):
                cashouts = CASH_OUTS.get(padrao_ativo, CASH_OUTS["5th_house"])
                ajustar_cashout_automatico(*cashouts)
                print(f"üîé Padr√£o CRMA em andamento '{padrao_ativo}'. Continuando ca√ßada. Cashouts: {cashouts}")
                casas_em_padrao += 1
                # Aqui voc√™ pode chamar sua l√≥gica de aposta padr√£o, se desejar.
            else:
                print(f"‚ö†Ô∏è Padr√£o CRMA '{padrao_ativo}' QUEBROU antes do Rosa. Voltando a aguardar Rosa para ativar 5¬™ casa.")
                padrao_ativo = None
                casas_em_padrao = 0

        # 2. Se n√£o h√° padr√£o ativo, e estamos na 5¬™ casa ap√≥s Rosa, verifique os padr√µes CRMA antes de apostar
        if not padrao_ativo and detectou_rosa and casas_passadas == 4:
            padrao_encontrado = None
            for padrao in CRMA_PATTERNS:
                if check_pattern_similarity(rodadas, padrao):
                    padrao_encontrado = padrao
                    break
            if padrao_encontrado:
                padrao_ativo = padrao_encontrado
                casas_em_padrao = 1
                cashouts = CASH_OUTS[padrao_encontrado]
                ajustar_cashout_automatico(*cashouts)
                print(f"üîé Novo padr√£o CRMA detectado '{padrao_encontrado}'. Iniciando ca√ßa ao padr√£o. Cashouts: {cashouts}")
                # Aqui voc√™ pode chamar sua l√≥gica de aposta padr√£o, se desejar.
            else:
                # Nenhum padr√£o, segue normalmente para 5¬™ casa ap√≥s Rosa
                cashouts = CASH_OUTS["5th_house"]
                ajustar_cashout_automatico(*cashouts)
                print("üîé Nenhum padr√£o CRMA detectado. Usando cashouts padr√£o da 5¬™ casa.")
                # --- BLOCO DA 5¬™ CASA ORIGINAL ABAIXO ---
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                total_perda = 0.0
                try:
                    saldo_clean = saldo.replace('Kz', '').replace('AOA', '').replace(',', '.').strip()
                    saldo_float = float(saldo_clean)
                except:
                    saldo_float = 0.0
                aposta1 = None
                aposta2 = None
                if martingale_count_1 < limite_martingale:
                    aposta1 = apostar_com_base_na_banca(martingale_count_1, 1)
                if martingale_count_2 < limite_martingale:
                    aposta2 = apostar_com_base_na_banca(martingale_count_2, 2)
                if aposta1 is not None and aposta2 is not None:
                    print(f"üéØ {casas_passadas + 1}¬™ casa chegou! Fazendo entradas simult√¢neas...")

                    threads = []
                    t1 = threading.Thread(target=lambda: clicar_botao(botao1_xpath))
                    t2 = threading.Thread(target=lambda: clicar_botao(botao2_xpath))
                    threads.append(t1)
                    threads.append(t2)
                    t1.start()
                    t2.start()
                    for t in threads:
                        t.join()
                    time.sleep(5)
                    resultado1, multiplicador1 = verificar_resultado(aposta1, 1.49)
                    resultado2, multiplicador2 = verificar_resultado(aposta2, 1.90)
                    if aposta1 is not None:
                        if resultado1:
                            vitorias += 1
                            lucro = aposta1 * (1.49 - 1)
                            lucro_acumulado += lucro
                            ultimo_resultado = f"Vit√≥ria (+Kz {lucro:.2f})"
                            print(f"üèÜ Vit√≥ria na 1¬™ aposta! Lucro: Kz {lucro:.2f}.")
                            salvar_entrada(aposta1, martingale_count_1, "Vit√≥ria", lucro, multiplicador1)
                            martingale_count_1 = limite_martingale
                        else:
                            total_perda += aposta1
                            historico_martingale.append(f"1¬™ aposta (tentativa {martingale_count_1 + 1}): Falha - Kz {aposta1:.2f}")
                            print(f"‚ö° 1¬™ aposta falhou (tentativa {martingale_count_1 + 1}).")
                            martingale_count_1 += 1
                    if aposta2 is not None:
                        if resultado2:
                            vitorias += 1
                            lucro = aposta2 * (1.90 - 1)
                            lucro_acumulado += lucro
                            ultimo_resultado = f"Vit√≥ria (+Kz {lucro:.2f})"
                            print(f"üèÜ Vit√≥ria na 2¬™ aposta! Lucro: Kz {lucro:.2f}.")
                            salvar_entrada(aposta2, martingale_count_2, "Vit√≥ria", lucro, multiplicador2)
                            martingale_count_2 = limite_martingale
                        else:
                            total_perda += aposta2
                            historico_martingale.append(f"2¬™ aposta (tentativa {martingale_count_2 + 1}): Falha - Kz {aposta2:.2f}")
                            print(f"‚ö° 2¬™ aposta falhou (tentativa {martingale_count_2 + 1}).")
                            martingale_count_2 += 1
                    if martingale_count_1 >= limite_martingale and martingale_count_2 >= limite_martingale:
                        if total_perda > 0 and not (resultado1 and resultado2):
                            derrotas += 1
                            perdas_acumuladas += total_perda
                            ultimo_resultado = f"Derrota (-Kz {total_perda:.2f})"
                            print(f"üíÄ Derrota nas apostas ap√≥s todas as tentativas de MG. Perda total: Kz {total_perda:.2f}.")
                            mt_ref = max(martingale_count_1, martingale_count_2)
                            mult_ref = max(multiplicador1, multiplicador2) if multiplicador1 > 0 or multiplicador2 > 0 else 0
                            salvar_entrada(max(aposta1, aposta2) if aposta1 or aposta2 else 0, mt_ref, "Derrota", -total_perda, mult_ref)
                        resetar_estrategia()
                        apostar_com_base_na_banca(0, 1)
                        apostar_com_base_na_banca(0, 2)
                        continue

        time.sleep(1)

# ... RESTANTE DO SEU C√ìDIGO SEGUIDO NORMALMENTE ...

# Configura√ß√£o do Selenium
options = Options()
options.add_argument("--disable-logging")
options.add_argument("--start-maximized")
options.add_argument("--disable-blink-features=AutomationControlled")
options.set_preference("dom.webdriver.enabled", False)
options.set_preference("useAutomationExtension", False)

# Vari√°veis globais
iframe_externo = None
iframe_interno = None
driver = None
casas_passadas = 0
detectou_rosa = False
ultima_vela_rosa = 0.0
martingale_count_1 = 0
martingale_count_2 = 0
limite_martingale = 2
base_bet_percentage_1 = 0.02  # 2% para a 1¬™ aposta
base_bet_percentage_2 = 0.01  # 1% para a 2¬™ aposta
vitorias = 0
derrotas = 0
lucro_acumulado = 0.0
perdas_acumuladas = 0.0
ultimo_resultado = "N/A"
historico_entradas = []
saldo = "N/A"
rodadas = []
rodadas_apos_rosa = []
historico_martingale = []
ultimo_multiplicador_processado = None

# XPaths dos bot√µes e elementos
botao1_xpath = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[1]/div[2]/div[2]/button"
botao2_xpath = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[1]/div[3]/div[2]/button"
cashout_xpath = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[1]/div[3]/div[2]/button"

# XPaths para cashout autom√°tico
auto_cashout_button_1 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[1]/div[1]/app-navigation-switcher/div/button[2]"
auto_cashout_switch_1 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[3]/div/div[2]/div[1]/app-ui-switcher/div"
auto_cashout_input_1 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[3]/div/div[2]/div[2]/div/app-spinner/div/div[2]/input"

auto_cashout_button_2 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[1]/div[2]/app-navigation-switcher/div/button[2]"
auto_cashout_switch_2 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[3]/div/div[2]/div[1]/app-ui-switcher/div"
auto_cashout_input_2 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[3]/div/div[2]/div[2]/div/app-spinner/div/div[2]/input"

# Banco de dados
def conectar():
    return sqlite3.connect("historico_aviator.db")

def criar_tabelas():
    conn = conectar()
    cursor = conn.cursor()
    cursor.execute("DROP TABLE IF EXISTS rodadas")
    cursor.execute(""" 
        CREATE TABLE rodadas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            multiplicador FLOAT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    """)
    cursor.execute("DROP TABLE IF EXISTS entradas")
    cursor.execute(""" 
        CREATE TABLE entradas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            aposta FLOAT,
            martingale INTEGER,
            outcome TEXT,
            profit_loss FLOAT,
            multiplicador FLOAT
        )
    """)
    conn.commit()
    conn.close()

criar_tabelas()

def salvar_rodada(multiplicador):
    conn = conectar()
    cursor = conn.cursor()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute("INSERT INTO rodadas (multiplicador, timestamp) VALUES (?, ?)", (multiplicador, timestamp))
    conn.commit()
    conn.close()

def salvar_entrada(aposta, martingale, outcome, profit_loss, multiplicador):
    conn = conectar()
    cursor = conn.cursor()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute(
        "INSERT INTO entradas (timestamp, aposta, martingale, outcome, profit_loss, multiplicador) VALUES (?, ?, ?, ?, ?, ?)",
        (timestamp, aposta, martingale, outcome, profit_loss, multiplicador)
    )
    conn.commit()
    conn.close()
    exportar_historico_excel()
    atualizar_tabela_historico(timestamp, aposta, martingale, outcome, profit_loss, multiplicador)

def exportar_historico_excel():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("SELECT timestamp, aposta, martingale, outcome, profit_loss, multiplicador FROM entradas ORDER BY timestamp DESC")
        entradas = cursor.fetchall()
        conn.close()

        df = pd.DataFrame(entradas, columns=["Timestamp", "Aposta", "Martingale", "Outcome", "Profit_Loss", "Multiplicador"])
        df["Aposta"] = df["Aposta"].apply(lambda x: f"Kz {x:.2f}")
        df["Profit_Loss"] = df["Profit_Loss"].apply(lambda x: f"{'+' if x >= 0 else ''}Kz {abs(x):.2f}")
        df["Multiplicador"] = df["Multiplicador"].apply(lambda x: f"{x:.2f}x")
        df["Martingale"] = df["Martingale"].apply(lambda x: f"{x} ({'Base' if x == 0 else 'x' + str(2**x)})")

        now = datetime.now()
        data_diaria = now.strftime("%Y-%m-%d")
        df_diario = df[df["Timestamp"].str.startswith(data_diaria)]
        df_diario.to_excel(f"historico_diario_{data_diaria}.xlsx", index=False)

        inicio_semana = now - timedelta(days=now.weekday())
        fim_semana = inicio_semana + timedelta(days=6)
        semana_str = f"{inicio_semana.strftime('%Y-%m-%d')}_a_{fim_semana.strftime('%Y-%m-%d')}"
        df_semanal = df[(df["Timestamp"] >= inicio_semana.strftime("%Y-%m-%d")) & (df["Timestamp"] <= fim_semana.strftime("%Y-%m-%d"))]
        df_semanal.to_excel(f"historico_semanal_{semana_str}.xlsx", index=False)

        mes_str = now.strftime("%Y-%m")
        df_mensal = df[df["Timestamp"].str.startswith(mes_str)]
        df_mensal.to_excel(f"historico_mensal_{mes_str}.xlsx", index=False)

        print(f"üìä Hist√≥rico exportado para Excel: Di√°rio ({data_diaria}), Semanal ({semana_str}), Mensal ({mes_str})")
    except Exception as e:
        print(f"‚ùå Erro ao exportar hist√≥rico para Excel: {e}")

def obter_ultimas_rodadas(n=20):
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("SELECT multiplicador FROM rodadas ORDER BY timestamp DESC LIMIT ?", (n,))
        dados = [row[0] for row in cursor.fetchall()]
        conn.close()
        return dados
    except Exception as e:
        print(f"‚ùå Erro ao obter √∫ltimas rodadas: {e}")
        return []

def obter_estatisticas(periodo):
    try:
        conn = conectar()
        cursor = conn.cursor()
        now = datetime.now()
        if periodo == "Di√°rio":
            start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        elif periodo == "Semanal":
            start = now - timedelta(days=now.weekday())
            start = start.replace(hour=0, minute=0, second=0, microsecond=0)
        elif periodo == "Mensal":
            start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        else:
            start = now.replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)

        cursor.execute("""
            SELECT outcome, profit_loss 
            FROM entradas 
            WHERE timestamp >= ?
        """, (start.strftime("%Y-%m-%d %H:%M:%S"),))

        vitorias = 0
        derrotas = 0
        lucro = 0.0
        perdas = 0.0

        for row in cursor.fetchall():
            outcome, profit_loss = row
            if outcome == "Vit√≥ria":
                vitorias += 1
                lucro += profit_loss
            elif outcome == "Derrota":
                derrotas += 1
                perdas += abs(profit_loss)

        conn.close()
        return vitorias, derrotas, lucro, perdas
    except Exception as e:
        print(f"‚ùå Erro ao obter estat√≠sticas para {periodo}: {e}")
        return 0, 0, 0.0, 0.0

def obter_entradas_historico():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("SELECT timestamp, aposta, martingale, outcome, profit_loss, multiplicador FROM entradas ORDER BY timestamp DESC LIMIT 100")
        entradas = [
            {
                "timestamp": row[0],
                "aposta": row[1],
                "martingale": row[2],
                "outcome": row[3],
                "profit_loss": row[4],
                "multiplicador": row[5]
            }
            for row in cursor.fetchall()
        ]
        conn.close()
        return entradas
    except Exception as e:
        print(f"‚ùå Erro ao obter hist√≥rico de entradas: {e}")
        return []

def obter_saldo():
    global driver, iframe_externo, iframe_interno
    try:
        driver.switch_to.default_content()
        saldo_element = WebDriverWait(driver, 20).until(
            EC.presence_of_element_located((By.XPATH, '//span[contains(@class, "balance") or contains(text(), "Kz")]'))
        )
        saldo = saldo_element.text.strip()
        print(f"Saldo capturado: {saldo}")
        driver.switch_to.frame(iframe_externo)
        driver.switch_to.frame(iframe_interno)
        return saldo
    except Exception as e:
        print(f"Erro ao obter saldo: {e}")
        try:
            saldo_element = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, '//header//span[contains(text(), "Kz")]'))
            )
            saldo = saldo_element.text.strip()
            print(f"Saldo capturado (fallback): {saldo}")
            driver.switch_to.frame(iframe_externo)
            driver.switch_to.frame(iframe_interno)
            return saldo
        except Exception as e2:
            print(f"Erro no fallback: {e2}")
            driver.switch_to.frame(iframe_externo)
            driver.switch_to.frame(iframe_interno)
            return "N/A"

def generate_ohlc(data, group_size=5):
    ohlc_data = []
    num_groups = len(data) // group_size
    for i in range(num_groups):
        chunk = data[i*group_size:(i+1)*group_size]
        open_ = chunk[0]
        high = max(chunk)
        low = min(chunk)
        close = chunk[-1]
        ohlc_data.append((open_, high, low, close))
    return ohlc_data

def on_mouse_wheel(event, ax, canvas):
    if not ax:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    xlim = ax.get_xlim()
    ylim = ax.get_ylim()
    zoom_factor = 1.2 if event.delta > 0 else 1 / 1.2
    new_xlim = [x - (x - xlim[0]) * zoom_factor, x + (xlim[1] - x) * zoom_factor]
    new_ylim = [y - (y - ylim[0]) * zoom_factor, y + (ylim[1] - y) * zoom_factor]
    ax.set_xlim(new_xlim)
    ax.set_ylim(new_ylim)
    canvas.draw_idle()

def analisar_tendencia(rodadas, window=5):
    if len(rodadas) < window * 2:
        return "Insuficiente", "gray"

    medias = []
    for i in range(0, len(rodadas) - window + 1, window):
        bloco = rodadas[i:i + window]
        if len(bloco) == window:
            medias.append(sum(bloco) / window)

    if len(medias) < 2:
        return "Insuficiente", "gray"

    ultima_media = medias[-1]
    penultima_media = medias[-2]
    margem = 0.5

    if ultima_media > penultima_media + margem:
        return "Alta", "green"
    elif ultima_media < penultima_media - margem:
        return "Baixa", "red"
    else:
        return "Lateral", "yellow"

def analisar_velas_rosa(rodadas):
    if not rodadas:
        return "Nenhuma vela rosa", len(rodadas), "Baixa"

    indices_rosa = [i for i, x in enumerate(rodadas) if x >= 10.0]

    if not indices_rosa:
        return "Nenhuma vela rosa", len(rodadas), "Baixa"

    intervalos = []
    for i in range(1, len(indices_rosa)):
        intervalos.append(indices_rosa[i] - indices_rosa[i-1])

    intervalo_medio = sum(intervalos) / len(intervalos) if intervalos else len(rodadas)
    ultima_rosa = indices_rosa[0]
    distancia = ultima_rosa

    if distancia >= intervalo_medio:
        probabilidade = "Alta"
    elif distancia >= intervalo_medio * 0.5:
        probabilidade = "M√©dia"
    else:
        probabilidade = "Baixa"

    return f"{distancia} rodadas atr√°s", intervalo_medio, probabilidade

def mostrar_grafico_detetive(canvas_frame, rodadas):
    for widget in canvas_frame.winfo_children():
        widget.destroy()
    if not rodadas or len(rodadas) < 5:
        label = tk.Label(canvas_frame, text="Aguardando mais rodadas para exibir o gr√°fico...", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    ohlc_data = generate_ohlc(rodadas)
    if not ohlc_data:
        label = tk.Label(canvas_frame, text="Sem dados suficientes para o gr√°fico.", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    fig, ax = plt.subplots(figsize=(8, 4))
    width = 0.4
    for i, (open_, high, low, close) in enumerate(ohlc_data):
        cor = 'green' if close >= open_ else 'red'
        ax.plot([i, i], [low, high], color='black', linewidth=1)
        ax.add_patch(Rectangle((i - width/2, min(open_, close)), width, abs(close - open_), color=cor))
        grupo = rodadas[i*5:(i+1)*5]
        voos_str = ", ".join([f"{v:.2f}" for v in grupo])
        ax.text(i + 0.1, high + 0.5, voos_str, fontsize=8, rotation=45, color='blue')
    ax.set_xticks(range(len(ohlc_data)))
    ax.set_title("Modo Detetive - Gr√°fico Candlestick com Multiplicadores")
    ax.set_xlabel("Grupo de Rodadas")
    ax.set_ylabel("Multiplicador (x)")
    ax.grid(True)
    canvas = FigureCanvasTkAgg(fig, master=canvas_frame)
    canvas.draw()
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
    toolbar = NavigationToolbar2Tk(canvas, canvas_frame)
    toolbar.update()
    toolbar.pack(side=tk.BOTTOM, fill=tk.X)
    def mouse_wheel_event(event):
        on_mouse_wheel(event, ax, canvas)
    canvas.mpl_connect('scroll_event', mouse_wheel_event)

def mostrar_grafico_analista(canvas_frame, rodadas):
    for widget in canvas_frame.winfo_children():
        widget.destroy()
    if not rodadas or len(rodadas) < 5:
        label = tk.Label(canvas_frame, text="Aguardando mais rodadas para exibir o gr√°fico...", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    ohlc_data = generate_ohlc(rodadas)
    if not ohlc_data:
        label = tk.Label(canvas_frame, text="Sem dados suficientes para o gr√°fico.", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    dates = pd.date_range('2025-01-01', periods=len(ohlc_data))
    df = pd.DataFrame(ohlc_data, columns=["Open", "High", "Low", "Close"], index=dates)
    mc = mpf.make_marketcolors(up='green', down='red', inherit=True)
    s = mpf.make_mpf_style(marketcolors=mc)
    fig = plt.figure(figsize=(8, 4))
    ax = fig.add_subplot(111)
    mpf.plot(df, type='candle', style=s, title="Modo Analista - Gr√°fico Candlestick", ylabel='Multiplicador (x)', ax=ax, returnfig=True)
    canvas = FigureCanvasTkAgg(fig, master=canvas_frame)
    canvas.draw()
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
    toolbar = NavigationToolbar2Tk(canvas, canvas_frame)
    toolbar.update()
    toolbar.pack(side=tk.BOTTOM, fill=tk.X)
    def mouse_wheel_event(event):
        on_mouse_wheel(event, ax, canvas)
    canvas.mpl_connect('scroll_event', mouse_wheel_event)

def update_stats(period, frame, stats_label):
    try:
        if period not in ["Di√°rio", "Semanal", "Mensal", "Anual"]:
            print(f"‚ö†Ô∏è Per√≠odo inv√°lido: {period}")
            return
        vitorias, derrotas, lucro, perdas = obter_estatisticas(period)
        lucro = float(lucro) if lucro is not None else 0.0
        perdas = float(perdas) if perdas is not None else 0.0
        if stats_label and hasattr(stats_label, 'config'):
            stats_label.config(text=f"Ganhos: {vitorias} | Perdas: {derrotas} | Lucro: Kz {lucro:.2f} | Perdas: Kz {perdas:.2f}")
        else:
            print(f"‚ö†Ô∏è stats_label inv√°lido para per√≠odo {period}")
    except Exception as e:
        print(f"‚ùå Erro ao atualizar estat√≠sticas para {period}: {e}")

def configurar_navegacao():
    global iframe_externo, iframe_interno, driver
    print("üì¢ Iniciando configura√ß√£o de navega√ß√£o...")

    try:
        # Inicializar o WebDriver
        gecko_path = GeckoDriverManager().install()
        print(f"‚úÖ geckodriver instalado em: {gecko_path}")
        webdriver_service = Service(gecko_path, log_path="geckodriver.log")
        driver = webdriver.Firefox(service=webdriver_service, options=options)
        driver.implicitly_wait(10)
        print("‚úÖ Firefox WebDriver iniciado com sucesso")

        # Acessar a p√°gina inicial
        print("üì¢ Navegando para o site...")
        driver.get("https://www.bantubet.co.ao/pt/games")
        time.sleep(15)
        driver.refresh()
        print("‚úÖ P√°gina inicial carregada e atualizada.")

        # Aguardar e clicar no bot√£o de login
        print("üì¢ Aguardando bot√£o de login...")
        login_button = WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "#root > div.layout-header-holder-bc > header > div.hdr-main-content-bc > div.hdr-user-bc > button.btn.s-small.sign-in"))
        )
        time.sleep(5)
        login_button.click()
        print("‚úÖ Bot√£o de login clicado.")

        # Preencher campos de login
        print("üì¢ Preenchendo campos de login...")
        phone_input = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="root"]/div[6]/div/div/div/div/div/div[2]/form/div[1]/div[3]/div/label/input'))
        )
        phone_input.send_keys("923630632")
        time.sleep(2)
        password_input = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="root"]/div[6]/div/div/div/div/div/div[2]/form/div[1]/div[4]/div/label/input'))
        )
        password_input.send_keys("Ag9327777771317")
        time.sleep(4)
        submit_button = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="root"]/div[6]/div/div/div/div/div/div[2]/form/div[1]/div[6]/div/button'))
        )
        submit_button.click()
        print("üì¢ Login enviado, aguardando redirecionamento...")
        time.sleep(10)

        # Verificar login
        try:
            WebDriverWait(driver, 30).until(
                EC.presence_of_element_located((By.XPATH, '//span[contains(@class, "balance") or contains(text(), "Kz")]'))
            )
            print("‚úÖ Login bem-sucedido! Saldo vis√≠vel.")
        except Exception as e:
            print(f"‚ùå Falha ao verificar login: {e}")
            raise Exception("Login n√£o foi bem-sucedido. Verifique as credenciais ou a p√°gina de login.")

        # Acessar a p√°gina do jogo Aviator
        print("üì¢ Acessando p√°gina do jogo Aviator...")
        driver.get("https://www.bantubet.co.ao/pt/games?openGames=806666-real&gameNames=Aviator")
        time.sleep(15)

        # Localizar iframe externo
        print("üì¢ Localizando iframe externo...")
        iframe_externo = WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="root"]/div[3]/div[1]/div[1]/div/iframe'))
        )
        driver.switch_to.frame(iframe_externo)
        print("‚úÖ Iframe externo encontrado e acessado.")
        time.sleep(10)

        # Localizar iframe interno
        print("üì¢ Localizando iframe interno...")
        iframe_interno = WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="gameFrame"]'))
        )
        driver.switch_to.frame(iframe_interno)
        print("‚úÖ Iframe interno encontrado e acessado.")
        time.sleep(10)

        # Verificar se o jogo carregou
        try:
            WebDriverWait(driver, 30).until(
                EC.presence_of_element_located((By.CLASS_NAME, 'result-history'))
            )
            print("‚úÖ Jogo Aviator carregado com sucesso. Hist√≥rico vis√≠vel.")
        except Exception as e:
            print(f"‚ùå Falha ao carregar o jogo: {e}")
            raise Exception("N√£o foi poss√≠vel carregar o jogo Aviator. Verifique a URL ou a conex√£o.")

    except Exception as e:
        print(f"‚ùå Erro cr√≠tico na configura√ß√£o de navega√ß√£o: {e}")
        print("üì¢ Tentando capturar screenshot para depura√ß√£o...")
        try:
            driver.save_screenshot("erro_navegacao.png")
            print("‚úÖ Screenshot salvo como 'erro_navegacao.png'.")
        except:
            print("‚ö†Ô∏è Falha ao salvar screenshot.")
        if driver:
            driver.quit()
        exit(1)

# GUI e outras fun√ß√µes (mantidas do seu script original, com ajustes m√≠nimos)
root = tk.Tk()
root.title("Analisador de Rodadas - Piloto Autom√°tico")
root.geometry("1200x800")
root.configure(bg="#1e1e1e")

main_pane = ttk.PanedWindow(root, orient=tk.VERTICAL)
main_pane.pack(fill=tk.BOTH, expand=True)

stats_frame = ttk.Frame(main_pane)
main_pane.add(stats_frame, weight=1)

notebook = ttk.Notebook(stats_frame)
notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

stats_labels = {}

for period in ["Di√°rio", "Semanal", "Mensal", "Anual"]:
    frame = ttk.Frame(notebook)
    notebook.add(frame, text=period)
    top_label = tk.Label(frame, text=f"Saldo: {saldo} | Total de Ganhos Operacionais: Kz {lucro_acumulado - perdas_acumuladas:.2f}", font=("Arial", 12), fg="white", bg="#1e1e1e")
    top_label.pack(pady=5, fill=tk.X)
    stats_label = tk.Label(frame, text="", font=("Arial", 10), fg="white", bg="#1e1e1e")
    stats_label.pack(pady=5, fill=tk.X)
    stats_labels[period] = (frame, stats_label)
    update_stats(period, frame, stats_label)

def on_tab_change(event):
    selected_tab = notebook.tab(notebook.select(), "text")
    frame, stats_label = stats_labels[selected_tab]
    update_stats(selected_tab, frame, stats_label)

notebook.bind("<<NotebookTabChanged>>", on_tab_change)

middle_pane = ttk.PanedWindow(main_pane, orient=tk.HORIZONTAL)
main_pane.add(middle_pane, weight=4)

chart_frame = ttk.Frame(middle_pane)
middle_pane.add(chart_frame, weight=2)
botoes_frame = ttk.Frame(chart_frame)
botoes_frame.pack(fill=tk.X, pady=5)
btn_detetive = ttk.Button(botoes_frame, text="Modo Detetive", command=lambda: mostrar_grafico_detetive(chart_frame, rodadas))
btn_analista = ttk.Button(botoes_frame, text="Modo Analista", command=lambda: mostrar_grafico_analista(chart_frame, rodadas))
btn_detetive.grid(row=0, column=0, padx=10)
btn_analista.grid(row=0, column=1, padx=10)
mostrar_grafico_detetive(chart_frame, rodadas)

right_pane = ttk.PanedWindow(middle_pane, orient=tk.VERTICAL)
middle_pane.add(right_pane, weight=1)

status_frame = ttk.Frame(right_pane)
right_pane.add(status_frame, weight=1)

status_frame.grid_rowconfigure(0, weight=0)
status_frame.grid_rowconfigure(1, weight=0)
status_frame.grid_rowconfigure(2, weight=0)
status_frame.grid_rowconfigure(3, weight=0)
status_frame.grid_rowconfigure(4, weight=0)
status_frame.grid_rowconfigure(5, weight=0)
status_frame.grid_rowconfigure(6, weight=0)
status_frame.grid_rowconfigure(7, weight=0)
status_frame.grid_rowconfigure(8, weight=0)
status_frame.grid_columnconfigure(0, weight=1)

tk.Label(status_frame, text="Status da Estrat√©gia", font=("Arial", 12, "bold"), fg="white", bg="#1e1e1e").grid(row=0, column=0, pady=5, sticky="ew")
status_label = tk.Label(status_frame, text="Aguardando vela rosa (>= 10.0x) na 1¬™ posi√ß√£o", font=("Arial", 10), fg="white", bg="#1e1e1e")
status_label.grid(row=1, column=0, sticky="ew")
martingale_label = tk.Label(status_frame, text="Martingale: 0 (Aposta base)", font=("Arial", 10), fg="white", bg="#1e1e1e")
martingale_label.grid(row=2, column=0, sticky="ew")
resultado_label = tk.Label(status_frame, text="√öltima Entrada: N/A", font=("Arial", 10), fg="white", bg="#1e1e1e")
resultado_label.grid(row=3, column=0, sticky="ew")
total_gains_label = tk.Label(status_frame, text=f"Total de Ganhos Operacionais: Kz {lucro_acumulado - perdas_acumuladas:.2f}", font=("Arial", 12), fg="white", bg="#1e1e1e")
total_gains_label.grid(row=4, column=0, pady=5, sticky="ew")

tendencia_label = tk.Label(status_frame, text="Tend√™ncia: Insuficiente", font=("Arial", 10), fg="gray", bg="#1e1e1e")
tendencia_label.grid(row=5, column=0, sticky="ew")
velas_rosa_label = tk.Label(status_frame, text="√öltima Vela Rosa: N/A | M√©dia: N/A | Probabilidade: N/A", font=("Arial", 10), fg="white", bg="#1e1e1e")
velas_rosa_label.grid(row=6, column=0, sticky="ew")

relatorio_label = tk.Label(status_frame, text="Relat√≥rio: Aguardando...", font=("Arial", 10), fg="white", bg="#1e1e1e", wraplength=300)
relatorio_label.grid(row=7, column=0, sticky="ew")

historico_mg_label = tk.Label(status_frame, text="Hist√≥rico de Martingale: Nenhum", font=("Arial", 10), fg="white", bg="#1e1e1e", wraplength=300)
historico_mg_label.grid(row=8, column=0, sticky="ew")

rodadas_container = ttk.Frame(right_pane)
right_pane.add(rodadas_container, weight=3)

tk.Label(rodadas_container, text="Extrator de Rodadas", font=("Arial", 12, "bold"), fg="white", bg="#1e1e1e").pack(fill=tk.X, pady=5)

canvas_rodadas = tk.Canvas(rodadas_container, bg="#1e1e1e")
scrollbar_rodadas = ttk.Scrollbar(rodadas_container, orient="vertical", command=canvas_rodadas.yview)
canvas_rodadas.configure(yscrollcommand=scrollbar_rodadas.set)

scrollbar_rodadas.pack(side=tk.RIGHT, fill=tk.Y)
canvas_rodadas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

rodadas_frame = ttk.Frame(canvas_rodadas)
canvas_rodadas.create_window((0, 0), window=rodadas_frame, anchor="nw")

for i in range(200):
    rodadas_frame.grid_rowconfigure(i, weight=1)
for j in range(6):
    rodadas_frame.grid_columnconfigure(j, weight=1)

rodadas_labels = []
for row in range(200):
    row_labels = []
    for col in range(6):
        label = tk.Label(
            rodadas_frame,
            text="N/A",
            font=("Arial", 8),
            fg="white",
            bg="#2e2e2e",
            width=8,
            height=1,
            anchor="center",
            relief="sunken"
        )
        label.grid(row=row, column=col, padx=2, pady=2, sticky="nsew")
        row_labels.append(label)
    rodadas_labels.append(row_labels)

def on_rodadas_frame_configure(event):
    canvas_rodadas.configure(scrollregion=canvas_rodadas.bbox("all"))

rodadas_frame.bind("<Configure>", on_rodadas_frame_configure)

def on_rodadas_mouse_scroll(event):
    if event.delta > 0:
        canvas_rodadas.yview_scroll(-1, "units")
    else:
        canvas_rodadas.yview_scroll(1, "units")

canvas_rodadas.bind_all("<MouseWheel>", on_rodadas_mouse_scroll)

historico_frame = ttk.Frame(main_pane)
main_pane.add(historico_frame, weight=1)
tk.Label(historico_frame, text="Hist√≥rico de Entradas", font=("Arial", 12, "bold"), fg="white", bg="#1e1e1e").pack(fill=tk.X)

colunas = ("Timestamp", "Bet Amount", "Martingale Level", "Outcome", "Profit/Loss", "Multiplicador")
tree = ttk.Treeview(historico_frame, columns=colunas, show="headings", height=10)
tree.heading("Timestamp", text="Data/Hora")
tree.heading("Bet Amount", text="Valor Apostado")
tree.heading("Martingale Level", text="N√≠vel Martingale")
tree.heading("Outcome", text="Resultado")
tree.heading("Profit/Loss", text="Lucro/Perda")
tree.heading("Multiplicador", text="Multiplicador")
tree.column("Timestamp", width=150, anchor="center")
tree.column("Bet Amount", width=100, anchor="center")
tree.column("Martingale Level", width=120, anchor="center")
tree.column("Outcome", width=100, anchor="center")
tree.column("Profit/Loss", width=100, anchor="center")
tree.column("Multiplicador", width=100, anchor="center")

scroll_y = ttk.Scrollbar(historico_frame, orient="vertical", command=tree.yview)
scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
tree.configure(yscrollcommand=scroll_y.set)
tree.pack(fill=tk.BOTH, expand=True)

tree.tag_configure("oddrow", background="#2e2e2e")
tree.tag_configure("evenrow", background="#3e3e3e")

def tree_scroll(event):
    if event.delta > 0:
        tree.yview_scroll(-1, "units")
    else:
        tree.yview_scroll(1, "units")
    return "break"

tree.bind("<MouseWheel>", tree_scroll)

def atualizar_tabela_historico(timestamp, aposta, martingale, outcome, profit_loss, multiplicador):
    global historico_entradas
    entrada = {
        "timestamp": timestamp,
        "aposta": f"Kz {aposta:.2f}",
        "martingale": f"{martingale} ({'Base' if martingale == 0 else 'x' + str(2**martingale)})",
        "outcome": outcome,
        "profit_loss": f"{'+' if profit_loss >= 0 else ''}Kz {abs(profit_loss):.2f}",
        "multiplicador": f"{multiplicador:.2f}x"
    }
    historico_entradas.insert(0, entrada)
    if len(historico_entradas) > 100:
        historico_entradas.pop()
    for item in tree.get_children():
        tree.delete(item)
    for idx, entrada in enumerate(historico_entradas):
        tag = "evenrow" if idx % 2 == 0 else "oddrow"
        tree.insert("", tk.END, values=(
            entrada["timestamp"],
            entrada["aposta"],
            entrada["martingale"],
            entrada["outcome"],
            entrada["profit_loss"],
            entrada["multiplicador"]
        ), tags=(tag,))
    print(f"üìù Hist√≥rico atualizado: {entrada}")

def get_color(multiplicador):
    if multiplicador >= 10.0:
        return "#FF69B4"
    elif multiplicador >= 2.0:
        return "#800080"
    else:
        return "#87CEEB"

def atualizar_extrator_rodadas():
    for row in range(200):
        for col in range(6):
            idx = row * 6 + col
            if idx < len(rodadas):
                multiplicador = rodadas[idx]
                rodadas_labels[row][col].config(text=f"{multiplicador:.2f}x", bg=get_color(multiplicador), fg="white")
            else:
                rodadas_labels[row][col].config(text="N/A", bg="#2e2e2e", fg="white")

def atualizar_status():
    global casas_passadas, detectou_rosa, ultima_vela_rosa, martingale_count_1, martingale_count_2, ultimo_resultado, lucro_acumulado, perdas_acumuladas, saldo, rodadas, rodadas_apos_rosa
    try:
        if not detectou_rosa:
            status_label.config(text="Aguardando vela rosa (>= 10.0x) na 1¬™ posi√ß√£o")
        elif casas_passadas < 4:
            status_label.config(text=f"{casas_passadas + 1}¬™ casa ap√≥s rosa ({ultima_vela_rosa:.2f}x)")
        elif casas_passadas == 4:
            status_label.config(text="Entrando na 5¬™ casa ap√≥s rosa")
        else:
            status_label.config(text=f"Tentativa de Martingale na {casas_passadas + 1}¬™ casa ap√≥s rosa")
        martingale_label.config(text=f"Martingale 1: {martingale_count_1} | Martingale 2: {martingale_count_2}")
        resultado_label.config(text=f"√öltima Entrada: {ultimo_resultado}")
        total_gains_label.config(text=f"Total de Ganhos Operacionais: Kz {lucro_acumulado - perdas_acumuladas:.2f}")

        tendencia, cor = analisar_tendencia(rodadas)
        tendencia_label.config(text=f"Tend√™ncia: {tendencia}", fg=cor)

        distancia, intervalo_medio, probabilidade = analisar_velas_rosa(rodadas)
        velas_rosa_label.config(text=f"√öltima Vela Rosa: {distancia} rodadas atr√°s | M√©dia: {intervalo_medio:.1f} rodadas | Probabilidade: {probabilidade}")

        if detectou_rosa and ultima_vela_rosa:
            relatorio = f"Relat√≥rio: √öltima Vela Rosa detectada: {ultima_vela_rosa:.2f}x\n"
            if rodadas_apos_rosa:
                for i in range(len(rodadas_apos_rosa)):
                    relatorio += f"{i + 1}¬™ casa ap√≥s o rosa: {rodadas_apos_rosa[i]:.2f}x\n"
            relatorio_label.config(text=relatorio)
        else:
            relatorio_label.config(text="Relat√≥rio: Aguardando vela rosa...")

        if historico_martingale:
            mg_text = "Hist√≥rico de Martingale:\n" + "\n".join(historico_martingale[-5:])
            historico_mg_label.config(text=mg_text)
        else:
            historico_mg_label.config(text="Hist√≥rico de Martingale: Nenhum")

        new_saldo = obter_saldo()
        if new_saldo != "N/A":
            saldo = new_saldo
        for period in stats_labels:
            frame, stats_label = stats_labels.get(period, (None, None))
            if frame and stats_label:
                root.after(0, lambda p=period, f=frame, s=stats_label: update_stats(p, f, s))
                top_label = frame.winfo_children()[0]
                top_label.config(text=f"Saldo: {saldo} | Total de Ganhos Operacionais: Kz {lucro_acumulado - perdas_acumuladas:.2f}")
            else:
                print(f"‚ö†Ô∏è Frame ou stats_label inv√°lido para {period}")
    except Exception as e:
        print(f"‚ùå Erro em atualizar_status: {e}")
    root.after(1000, atualizar_status)

def configurar_cashout_automatico():
    try:
        print("üì¢ Ativando cashout autom√°tico para a 1¬™ aposta...")
        auto_button_1 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_button_1))
        )
        auto_button_1.click()
        print("‚úÖ Bot√£o de cashout autom√°tico da 1¬™ aposta clicado.")

        auto_switch_1 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_switch_1))
        )
        driver.execute_script("arguments[0].click();", auto_switch_1)
        print("‚úÖ Switch de cashout autom√°tico da 1¬™ aposta ativado.")

        auto_input_1 = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, auto_cashout_input_1))
        )
        auto_input_1.send_keys(Keys.CONTROL + "a")
        auto_input_1.send_keys(Keys.DELETE)
        auto_input_1.send_keys("1.49")
        print("‚úÖ Valor de cashout autom√°tico da 1¬™ aposta definido para 1.49x.")

        print("üì¢ Ativando cashout autom√°tico para a 2¬™ aposta...")
        auto_button_2 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_button_2))
        )
        driver.execute_script("arguments[0].click();", auto_button_2)
        print("‚úÖ Bot√£o de cashout autom√°tico da 2¬™ aposta clicado.")

        auto_switch_2 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_switch_2))
        )
        driver.execute_script("arguments[0].click();", auto_switch_2)
        print("‚úÖ Switch de cashout autom√°tico da 2¬™ aposta ativado.")

        auto_input_2 = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, auto_cashout_input_2))
        )
        auto_input_2.send_keys(Keys.CONTROL + "a")
        auto_input_2.send_keys(Keys.DELETE)
        auto_input_2.send_keys("1.90")
        print("‚úÖ Valor de cashout autom√°tico da 2¬™ aposta definido para 1.90x.")
    except Exception as e:
        print(f"‚ùå Erro ao configurar cashout autom√°tico: {e}")

def apostar_com_base_na_banca(martingale_count, aposta_idx):
    global saldo, base_bet_percentage_1, base_bet_percentage_2
    try:
        if saldo == "N/A":
            raise Exception("N√£o foi poss√≠vel obter o saldo")
        saldo_clean = saldo.replace('Kz', '').replace('AOA', '').replace(',', '.').strip()
        saldo_float = float(saldo_clean)
        base_percentage = base_bet_percentage_1 if aposta_idx == 1 else base_bet_percentage_2
        aposta = saldo_float * base_percentage * (2 ** martingale_count)
        print(f"üí∞ Aposta {aposta_idx} calculada: Kz {aposta:.2f} (Martingale n√≠vel {martingale_count}, {base_percentage * 100 * (2 ** martingale_count)}% do saldo)")

        input_aposta = WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, f'app-bet-control:nth-child({aposta_idx}) div.bet-block input')))
        input_aposta.send_keys(Keys.CONTROL + "a")
        input_aposta.send_keys(Keys.DELETE)
        time.sleep(0.5)
        input_aposta.send_keys(str(aposta))

        print(f"Valor da aposta {aposta_idx} definido: {aposta}")
        return aposta
    except Exception as e:
        print(f"‚ùå Erro ao calcular/configurar aposta {aposta_idx}: {e}")
        return None

def clicar_botao(xpath):
    try:
        botao = WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.XPATH, xpath)))
        if botao.is_enabled():
            botao.click()
            print(f"‚úÖ Clicou no bot√£o {xpath}")
            return True
        else:
            print(f"‚ùå Bot√£o {xpath} est√° desabilitado")
            return False
    except Exception as e:
        print(f"‚ùå Erro ao clicar no bot√£o {xpath}: {e}")
        return False

def pegar_historico_real():
    try:
        texto_historico = driver.find_element(By.CLASS_NAME, 'result-history').text
        if "Hist√≥rico da ronda" in texto_historico:
            linhas = texto_historico.split('\n')
            resultados = []
            for linha in linhas:
                if linha.strip() and "Hist√≥rico da ronda" not in linha:
                    try:
                        valor = float(linha.replace(',', '').replace('x', ''))
                        resultados.append(valor)
                    except ValueError:
                        continue
            return resultados if resultados else []
        else:
            resultados = [float(n.replace(',', '').replace('x', '')) for n in texto_historico.split('\n') if n.strip()]
            return resultados
    except Exception as e:
        print(f"‚ùå Erro ao capturar hist√≥rico: {e}")
        return []

def verificar_resultado(aposta, cashout):
    try:
        ultimo_resultado = pegar_historico_real()[0]
        print(f"üìä √öltimo multiplicador: {ultimo_resultado}x")
        return ultimo_resultado >= cashout, ultimo_resultado
    except Exception as e:
        print(f"‚ùå Erro ao verificar resultado: {e}")
        return False, 0.0

def resetar_estrategia():
    global detectou_rosa, casas_passadas, ultima_vela_rosa, martingale_count_1, martingale_count_2, rodadas_apos_rosa, historico_martingale
    detectou_rosa = False
    casas_passadas = 0
    ultima_vela_rosa = 0.0
    martingale_count_1 = 0
    martingale_count_2 = 0
    rodadas_apos_rosa = []
    historico_martingale = []
    print("üîÑ Estrat√©gia reiniciada. Aguardando pr√≥xima vela rosa...")

def realizar_aposta(aposta_idx, martingale_count, botao_xpath, cashout):
    aposta = apostar_com_base_na_banca(martingale_count, aposta_idx)
    if aposta is None:
        return False, 0.0, aposta
    if clicar_botao(botao_xpath):
        time.sleep(5)  # Tempo para o jogo processar a aposta
        resultado, multiplicador = verificar_resultado(aposta, cashout)
        return resultado, multiplicador, aposta
    return False, 0.0, aposta

def estrategia_principal():
    global casas_passadas, detectou_rosa, ultima_vela_rosa, martingale_count_1, martingale_count_2, ultimo_resultado, vitorias, derrotas, lucro_acumulado, perdas_acumuladas, saldo, rodadas, rodadas_apos_rosa, historico_martingale

    configurar_cashout_automatico()

    while True:
        historico = pegar_historico_real()
        if not historico or len(historico) < 5:
            print("‚ö†Ô∏è Hist√≥rico insuficiente ou n√£o capturado")
            time.sleep(2)
            continue
        print(f"üìà Hist√≥rico atual: {historico}")
        rodadas = historico

        if detectou_rosa and casas_passadas >= 4:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            total_perda = 0.0

            try:
                saldo_clean = saldo.replace('Kz', '').replace('AOA', '').replace(',', '.').strip()
                saldo_float = float(saldo_clean)
            except:
                saldo_float = 0.0

            aposta1 = None
            aposta2 = None
            if martingale_count_1 < limite_martingale:
                aposta1 = apostar_com_base_na_banca(martingale_count_1, 1)
            if martingale_count_2 < limite_martingale:
                aposta2 = apostar_com_base_na_banca(martingale_count_2, 2)

            if aposta1 is not None and aposta2 is not None:
                print(f"üéØ {casas_passadas + 1}¬™ casa chegou! Fazendo entradas simult√¢neas...")
                threads = []
                t1 = threading.Thread(target=lambda: clicar_botao(botao1_xpath))
                t2 = threading.Thread(target=lambda: clicar_botao(botao2_xpath))
                threads.append(t1)
                threads.append(t2)
                t1.start()
                t2.start()
                for t in threads:
                    t.join()

                time.sleep(5)

                resultado1, multiplicador1 = verificar_resultado(aposta1, 1.49)
                resultado2, multiplicador2 = verificar_resultado(aposta2, 1.90)

                if aposta1 is not None:
                    if resultado1:
                        vitorias += 1
                        lucro = aposta1 * (1.49 - 1)
                        lucro_acumulado += lucro
                        ultimo_resultado = f"Vit√≥ria (+Kz {lucro:.2f})"
                        print(f"üèÜ Vit√≥ria na 1¬™ aposta! Lucro: Kz {lucro:.2f}.")
                        salvar_entrada(aposta1, martingale_count_1, "Vit√≥ria", lucro, multiplicador1)
                        martingale_count_1 = limite_martingale
                    else:
                        total_perda += aposta1
                        historico_martingale.append(f"1¬™ aposta (tentativa {martingale_count_1 + 1}): Falha - Kz {aposta1:.2f}")
                        print(f"‚ö° 1¬™ aposta falhou (tentativa {martingale_count_1 + 1}).")
                        martingale_count_1 += 1

                if aposta2 is not None:
                    if resultado2:
                        vitorias += 1
                        lucro = aposta2 * (1.90 - 1)
                        lucro_acumulado += lucro
                        ultimo_resultado = f"Vit√≥ria (+Kz {lucro:.2f})"
                        print(f"üèÜ Vit√≥ria na 2¬™ aposta! Lucro: Kz {lucro:.2f}.")
                        salvar_entrada(aposta2, martingale_count_2, "Vit√≥ria", lucro, multiplicador2)
                        martingale_count_2 = limite_martingale
                    else:
                        total_perda += aposta2
                        historico_martingale.append(f"2¬™ aposta (tentativa {martingale_count_2 + 1}): Falha - Kz {aposta2:.2f}")
                        print(f"‚ö° 2¬™ aposta falhou (tentativa {martingale_count_2 + 1}).")
                        martingale_count_2 += 1

                if martingale_count_1 >= limite_martingale and martingale_count_2 >= limite_martingale:
                    if total_perda > 0 and not (resultado1 and resultado2):
                        derrotas += 1
                        perdas_acumuladas += total_perda
                        ultimo_resultado = f"Derrota (-Kz {total_perda:.2f})"
                        print(f"üíÄ Derrota nas apostas ap√≥s todas as tentativas de MG. Perda total: Kz {total_perda:.2f}.")
                        mt_ref = max(martingale_count_1, martingale_count_2)
                        mult_ref = max(multiplicador1, multiplicador2) if multiplicador1 > 0 or multiplicador2 > 0 else 0
                        salvar_entrada(max(aposta1, aposta2) if aposta1 or aposta2 else 0, mt_ref, "Derrota", -total_perda, mult_ref)
                    resetar_estrategia()
                    apostar_com_base_na_banca(0, 1)
                    apostar_com_base_na_banca(0, 2)
                    continue

        time.sleep(1)

primeira_extracao = True
executando = False

def rodada_terminou():
    global ultimo_multiplicador_processado
    try:
        texto_resultado = driver.find_element(By.CLASS_NAME, 'result-history').text.replace('x', '').split('\n')[0]
        resultado_atual = float(texto_resultado.replace(',', ''))
        if ultimo_multiplicador_processado is None or resultado_atual != ultimo_multiplicador_processado:
            return True
        return False
    except:
        return False

def adicionar_rodada(numero):
    global rodadas, rodadas_apos_rosa, ultimo_multiplicador_processado, casas_passadas, detectou_rosa, ultima_vela_rosa
    rodadas.insert(0, numero)
    if len(rodadas) > 1200:
        rodadas.pop(-1)

    if numero >= 10.0:
        print(f"üî• Nova vela rosa detectada na 1¬™ posi√ß√£o: {numero:.2f}x! Reiniciando contagem...")
        ultima_vela_rosa = numero
        detectou_rosa = True
        casas_passadas = 0
        rodadas_apos_rosa = []
        historico_martingale = []
    elif detectou_rosa:
        rodadas_apos_rosa.append(numero)
        casas_passadas = len(rodadas_apos_rosa)
        print(f"‚è≥ {casas_passadas} nova(s) vela(s) ap√≥s rosa ({ultima_vela_rosa:.2f}x): {numero:.2f}x")

    ultimo_multiplicador_processado = numero
    salvar_rodada(numero)
    atualizar_extrator_rodadas()
    if len(rodadas) >= 5 and len(rodadas) % 5 == 0:
        mostrar_grafico_detetive(chart_frame, rodadas)

def extrair_rodadas():
    global primeira_extracao, executando
    if executando:
        return
    executando = True
    try:
        if rodada_terminou():
            resultados = [float(n.replace(',', '')) for n in driver.find_element(By.CLASS_NAME, 'result-history').text.replace('x', '').split('\n') if n.strip()]
            if resultados:
                nova_rodada = resultados[0]
                if primeira_extracao:
                    rodadas.extend(resultados)
                    primeira_extracao = False
                    if len(rodadas) >= 5:
                        mostrar_grafico_detetive(chart_frame, rodadas)
                else:
                    adicionar_rodada(nova_rodada)
    except Exception as e:
        print(f"Erro ao extrair rodadas: {e}")
    executando = False
    root.after(1000, extrair_rodadas)

def main():
    print("üì¢ Iniciando o bot...")
    try:
        configurar_navegacao()
        extrair_rodadas()
        atualizar_status()
        estrategia_thread = threading.Thread(target=estrategia_principal, daemon=True)
        estrategia_thread.start()
        root.mainloop()
    except Exception as e:
        print(f"‚ùå Erro cr√≠tico no main: {e}")
        if driver:
            driver.quit()
        exit(1)
    finally:
        print("üì¢ Encerrando o driver do Selenium...")
        if driver:
            driver.quit()

if __name__ == "__main__":
    main()