
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import matplotlib.dates as mdates
from matplotlib.patches import Rectangle
import mplfinance as mpf
import tkinter as tk
from tkinter import ttk
import sqlite3
from datetime import datetime, timedelta
from selenium import webdriver
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.firefox import GeckoDriverManager
import time
import threading

# ------------------- INÍCIO: LÓGICA CRMA E AJUSTE DE CASHOUT -------------------

CRMA_PATTERNS = ["RXR", "ROXR", "ROXOR", "ROOXXOOR", "AR", "AXR", "AOXR", "AOXOR", "AOOXXOOR"]

CASH_OUTS = {
    "RXR": [2.0, 3.0],
    "ROXR": [2.2, 3.2],
    "ROXOR": [2.5, 3.5],
    "ROOXXOOR": [3.0, 4.0],
    "AR": [1.8, 2.8],
    "AXR": [2.0, 3.0],
    "AOXR": [2.2, 3.2],
    "AOXOR": [2.5, 3.5],
    "AOOXXOOR": [3.0, 4.0],
    "5th_house": [1.49, 1.9]
}

def map_history_to_pattern(history, pattern_len):
    """Mapeia os últimos valores do histórico para letras conforme as regras."""
    rec = []
    for x in history[-pattern_len:]:
        if x >= 10.0:
            rec.append("A")
        elif x >= 2.0:
            rec.append("R")
        else:
            rec.append("X")
    return "".join(rec)

def check_pattern_similarity(history, pattern):
    """Retorna True se o histórico recente corresponde ao padrão (>=50% de acerto)."""
    pattern_len = len(pattern)
    if len(history) < pattern_len:
        return False
    history_pattern = map_history_to_pattern(history, pattern_len)
    matches = sum(1 for h, p in zip(history_pattern, pattern) if h == p)
    return (matches / pattern_len) >= 0.5

def ajustar_cashout_automatico(cashout1, cashout2):
    try:
        # 1ª aposta
        auto_button_1 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_button_1))
        )
        auto_button_1.click()
        auto_switch_1 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_switch_1))
        )
        driver.execute_script("arguments[0].click();", auto_switch_1)
        auto_input_1 = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, auto_cashout_input_1))
        )
        auto_input_1.send_keys(Keys.CONTROL + "a")
        auto_input_1.send_keys(Keys.DELETE)
        auto_input_1.send_keys(str(cashout1))
        # 2ª aposta
        auto_button_2 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_button_2))
        )
        driver.execute_script("arguments[0].click();", auto_button_2)
        auto_switch_2 = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, auto_cashout_switch_2))
        )
        driver.execute_script("arguments[0].click();", auto_switch_2)
        auto_input_2 = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, auto_cashout_input_2))
        )
        auto_input_2.send_keys(Keys.CONTROL + "a")
        auto_input_2.send_keys(Keys.DELETE)
        auto_input_2.send_keys(str(cashout2))
        print(f"Cashouts ajustados: {cashout1} e {cashout2}")
    except Exception as e:
        print(f"Erro ao ajustar cashouts: {e}")

# ------------------- FIM: LÓGICA CRMA E AJUSTE DE CASHOUT -------------------

# ... RESTANTE DO SEU CÓDIGO INALTERADO ATÉ A FUNÇÃO estrategia_principal() ...

# Substitua apenas a função estrategia_principal por esta versão:

def estrategia_principal():
    global casas_passadas, detectou_rosa, ultima_vela_rosa, martingale_count_1, martingale_count_2, ultimo_resultado, vitorias, derrotas, lucro_acumulado, perdas_acumuladas, saldo, rodadas, rodadas_apos_rosa

    configurar_cashout_automatico()
    padrao_ativo = None
    casas_em_padrao = 0

    while True:
        historico = pegar_historico_real()
        if not historico or len(historico) < 5:
            print("⚠️ Histórico insuficiente ou não capturado")
            time.sleep(2)
            continue
        print(f"📈 Histórico atual: {historico}")
        rodadas = historico

        # 1. Se houver um padrão CRMA ativo, continue seguindo enquanto ele corresponder
        if padrao_ativo:
            if check_pattern_similarity(rodadas, padrao_ativo):
                cashouts = CASH_OUTS.get(padrao_ativo, CASH_OUTS["5th_house"])
                ajustar_cashout_automatico(*cashouts)
                print(f"🔎 Padrão CRMA em andamento '{padrao_ativo}'. Continuando caçada. Cashouts: {cashouts}")
                casas_em_padrao += 1
                # Aqui você pode chamar sua lógica de aposta padrão, se desejar.
            else:
                print(f"⚠️ Padrão CRMA '{padrao_ativo}' QUEBROU antes do Rosa. Voltando a aguardar Rosa para ativar 5ª casa.")
                padrao_ativo = None
                casas_em_padrao = 0

        # 2. Se não há padrão ativo, e estamos na 5ª casa após Rosa, verifique os padrões CRMA antes de apostar
        if not padrao_ativo and detectou_rosa and casas_passadas == 4:
            padrao_encontrado = None
            for padrao in CRMA_PATTERNS:
                if check_pattern_similarity(rodadas, padrao):
                    padrao_encontrado = padrao
                    break
            if padrao_encontrado:
                padrao_ativo = padrao_encontrado
                casas_em_padrao = 1
                cashouts = CASH_OUTS[padrao_encontrado]
                ajustar_cashout_automatico(*cashouts)
                print(f"🔎 Novo padrão CRMA detectado '{padrao_encontrado}'. Iniciando caça ao padrão. Cashouts: {cashouts}")
                # Aqui você pode chamar sua lógica de aposta padrão, se desejar.
            else:
                # Nenhum padrão, segue normalmente para 5ª casa após Rosa
                cashouts = CASH_OUTS["5th_house"]
                ajustar_cashout_automatico(*cashouts)
                print("🔎 Nenhum padrão CRMA detectado. Usando cashouts padrão da 5ª casa.")
                # --- BLOCO DA 5ª CASA ORIGINAL ABAIXO ---
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                total_perda = 0.0
                try:
                    saldo_clean = saldo.replace('Kz', '').replace('AOA', '').replace(',', '.').strip()
                    saldo_float = float(saldo_clean)
                except:
                    saldo_float = 0.0
                aposta1 = None
                aposta2 = None
                if martingale_count_1 < limite_martingale:
                    aposta1 = apostar_com_base_na_banca(martingale_count_1, 1)
                if martingale_count_2 < limite_martingale:
                    aposta2 = apostar_com_base_na_banca(martingale_count_2, 2)
                if aposta1 is not None and aposta2 is not None:
                    print(f"🎯 {casas_passadas + 1}ª casa chegou! Fazendo entradas simultâneas...")

                    threads = []
                    t1 = threading.Thread(target=lambda: clicar_botao(botao1_xpath))
                    t2 = threading.Thread(target=lambda: clicar_botao(botao2_xpath))
                    threads.append(t1)
                    threads.append(t2)
                    t1.start()
                    t2.start()
                    for t in threads:
                        t.join()
                    time.sleep(5)
                    resultado1, multiplicador1 = verificar_resultado(aposta1, 1.49)
                    resultado2, multiplicador2 = verificar_resultado(aposta2, 1.90)
                    if aposta1 is not None:
                        if resultado1:
                            vitorias += 1
                            lucro = aposta1 * (1.49 - 1)
                            lucro_acumulado += lucro
                            ultimo_resultado = f"Vitória (+Kz {lucro:.2f})"
                            print(f"🏆 Vitória na 1ª aposta! Lucro: Kz {lucro:.2f}.")
                            salvar_entrada(aposta1, martingale_count_1, "Vitória", lucro, multiplicador1)
                            martingale_count_1 = limite_martingale
                        else:
                            total_perda += aposta1
                            historico_martingale.append(f"1ª aposta (tentativa {martingale_count_1 + 1}): Falha - Kz {aposta1:.2f}")
                            print(f"⚡ 1ª aposta falhou (tentativa {martingale_count_1 + 1}).")
                            martingale_count_1 += 1
                    if aposta2 is not None:
                        if resultado2:
                            vitorias += 1
                            lucro = aposta2 * (1.90 - 1)
                            lucro_acumulado += lucro
                            ultimo_resultado = f"Vitória (+Kz {lucro:.2f})"
                            print(f"🏆 Vitória na 2ª aposta! Lucro: Kz {lucro:.2f}.")
                            salvar_entrada(aposta2, martingale_count_2, "Vitória", lucro, multiplicador2)
                            martingale_count_2 = limite_martingale
                        else:
                            total_perda += aposta2
                            historico_martingale.append(f"2ª aposta (tentativa {martingale_count_2 + 1}): Falha - Kz {aposta2:.2f}")
                            print(f"⚡ 2ª aposta falhou (tentativa {martingale_count_2 + 1}).")
                            martingale_count_2 += 1
                    if martingale_count_1 >= limite_martingale and martingale_count_2 >= limite_martingale:
                        if total_perda > 0 and not (resultado1 and resultado2):
                            derrotas += 1
                            perdas_acumuladas += total_perda
                            ultimo_resultado = f"Derrota (-Kz {total_perda:.2f})"
                            print(f"💀 Derrota nas apostas após todas as tentativas de MG. Perda total: Kz {total_perda:.2f}.")
                            mt_ref = max(martingale_count_1, martingale_count_2)
                            mult_ref = max(multiplicador1, multiplicador2) if multiplicador1 > 0 or multiplicador2 > 0 else 0
                            salvar_entrada(max(aposta1, aposta2) if aposta1 or aposta2 else 0, mt_ref, "Derrota", -total_perda, mult_ref)
                        resetar_estrategia()
                        apostar_com_base_na_banca(0, 1)
                        apostar_com_base_na_banca(0, 2)
                        continue

        time.sleep(1)

# ... RESTANTE DO SEU CÓDIGO SEGUIDO NORMALMENTE ...

# Configuração do Selenium
options = Options()
options.add_argument("--disable-logging")
options.add_argument("--start-maximized")
options.add_argument("--disable-blink-features=AutomationControlled")
options.set_preference("dom.webdriver.enabled", False)
options.set_preference("useAutomationExtension", False)

# Variáveis globais
iframe_externo = None
iframe_interno = None
driver = None
casas_passadas = 0
detectou_rosa = False
ultima_vela_rosa = 0.0
martingale_count_1 = 0
martingale_count_2 = 0
limite_martingale = 2
base_bet_percentage_1 = 0.02  # 2% para a 1ª aposta
base_bet_percentage_2 = 0.01  # 1% para a 2ª aposta
vitorias = 0
derrotas = 0
lucro_acumulado = 0.0
perdas_acumuladas = 0.0
ultimo_resultado = "N/A"
historico_entradas = []
saldo = "N/A"
rodadas = []
rodadas_apos_rosa = []
historico_martingale = []
ultimo_multiplicador_processado = None

# XPaths dos botões e elementos
botao1_xpath = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[1]/div[2]/div[2]/button"
botao2_xpath = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[1]/div[3]/div[2]/button"
cashout_xpath = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[1]/div[3]/div[2]/button"

# XPaths para cashout automático
auto_cashout_button_1 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[1]/div[1]/app-navigation-switcher/div/button[2]"
auto_cashout_switch_1 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[3]/div/div[2]/div[1]/app-ui-switcher/div"
auto_cashout_input_1 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[1]/div/div[3]/div/div[2]/div[2]/div/app-spinner/div/div[2]/input"

auto_cashout_button_2 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[1]/div[2]/app-navigation-switcher/div/button[2]"
auto_cashout_switch_2 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[3]/div/div[2]/div[1]/app-ui-switcher/div"
auto_cashout_input_2 = "/html/body/app-root/app-game/div/div[1]/div[2]/div/div[2]/div[3]/app-bet-controls/div/app-bet-control[2]/div/div[3]/div/div[2]/div[2]/div/app-spinner/div/div[2]/input"

# Banco de dados
def conectar():
    return sqlite3.connect("historico_aviator.db")

def criar_tabelas():
    conn = conectar()
    cursor = conn.cursor()
    cursor.execute("DROP TABLE IF EXISTS rodadas")
    cursor.execute(""" 
        CREATE TABLE rodadas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            multiplicador FLOAT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    """)
    cursor.execute("DROP TABLE IF EXISTS entradas")
    cursor.execute(""" 
        CREATE TABLE entradas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            aposta FLOAT,
            martingale INTEGER,
            outcome TEXT,
            profit_loss FLOAT,
            multiplicador FLOAT
        )
    """)
    conn.commit()
    conn.close()

criar_tabelas()

def salvar_rodada(multiplicador):
    conn = conectar()
    cursor = conn.cursor()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute("INSERT INTO rodadas (multiplicador, timestamp) VALUES (?, ?)", (multiplicador, timestamp))
    conn.commit()
    conn.close()

def salvar_entrada(aposta, martingale, outcome, profit_loss, multiplicador):
    conn = conectar()
    cursor = conn.cursor()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute(
        "INSERT INTO entradas (timestamp, aposta, martingale, outcome, profit_loss, multiplicador) VALUES (?, ?, ?, ?, ?, ?)",
        (timestamp, aposta, martingale, outcome, profit_loss, multiplicador)
    )
    conn.commit()
    conn.close()
    exportar_historico_excel()
    atualizar_tabela_historico(timestamp, aposta, martingale, outcome, profit_loss, multiplicador)

def exportar_historico_excel():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("SELECT timestamp, aposta, martingale, outcome, profit_loss, multiplicador FROM entradas ORDER BY timestamp DESC")
        entradas = cursor.fetchall()
        conn.close()

        df = pd.DataFrame(entradas, columns=["Timestamp", "Aposta", "Martingale", "Outcome", "Profit_Loss", "Multiplicador"])
        df["Aposta"] = df["Aposta"].apply(lambda x: f"Kz {x:.2f}")
        df["Profit_Loss"] = df["Profit_Loss"].apply(lambda x: f"{'+' if x >= 0 else ''}Kz {abs(x):.2f}")
        df["Multiplicador"] = df["Multiplicador"].apply(lambda x: f"{x:.2f}x")
        df["Martingale"] = df["Martingale"].apply(lambda x: f"{x} ({'Base' if x == 0 else 'x' + str(2**x)})")

        now = datetime.now()
        data_diaria = now.strftime("%Y-%m-%d")
        df_diario = df[df["Timestamp"].str.startswith(data_diaria)]
        df_diario.to_excel(f"historico_diario_{data_diaria}.xlsx", index=False)

        inicio_semana = now - timedelta(days=now.weekday())
        fim_semana = inicio_semana + timedelta(days=6)
        semana_str = f"{inicio_semana.strftime('%Y-%m-%d')}_a_{fim_semana.strftime('%Y-%m-%d')}"
        df_semanal = df[(df["Timestamp"] >= inicio_semana.strftime("%Y-%m-%d")) & (df["Timestamp"] <= fim_semana.strftime("%Y-%m-%d"))]
        df_semanal.to_excel(f"historico_semanal_{semana_str}.xlsx", index=False)

        mes_str = now.strftime("%Y-%m")
        df_mensal = df[df["Timestamp"].str.startswith(mes_str)]
        df_mensal.to_excel(f"historico_mensal_{mes_str}.xlsx", index=False)

        print(f"📊 Histórico exportado para Excel: Diário ({data_diaria}), Semanal ({semana_str}), Mensal ({mes_str})")
    except Exception as e:
        print(f"❌ Erro ao exportar histórico para Excel: {e}")

def obter_ultimas_rodadas(n=20):
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("SELECT multiplicador FROM rodadas ORDER BY timestamp DESC LIMIT ?", (n,))
        dados = [row[0] for row in cursor.fetchall()]
        conn.close()
        return dados
    except Exception as e:
        print(f"❌ Erro ao obter últimas rodadas: {e}")
        return []

def obter_estatisticas(periodo):
    try:
        conn = conectar()
        cursor = conn.cursor()
        now = datetime.now()
        if periodo == "Diário":
            start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        elif periodo == "Semanal":
            start = now - timedelta(days=now.weekday())
            start = start.replace(hour=0, minute=0, second=0, microsecond=0)
        elif periodo == "Mensal":
            start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        else:
            start = now.replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)

        cursor.execute("""
            SELECT outcome, profit_loss 
            FROM entradas 
            WHERE timestamp >= ?
        """, (start.strftime("%Y-%m-%d %H:%M:%S"),))

        vitorias = 0
        derrotas = 0
        lucro = 0.0
        perdas = 0.0

        for row in cursor.fetchall():
            outcome, profit_loss = row
            if outcome == "Vitória":
                vitorias += 1
                lucro += profit_loss
            elif outcome == "Derrota":
                derrotas += 1
                perdas += abs(profit_loss)

        conn.close()
        return vitorias, derrotas, lucro, perdas
    except Exception as e:
        print(f"❌ Erro ao obter estatísticas para {periodo}: {e}")
        return 0, 0, 0.0, 0.0

def obter_entradas_historico():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("SELECT timestamp, aposta, martingale, outcome, profit_loss, multiplicador FROM entradas ORDER BY timestamp DESC LIMIT 100")
        entradas = [
            {
                "timestamp": row[0],
                "aposta": row[1],
                "martingale": row[2],
                "outcome": row[3],
                "profit_loss": row[4],
                "multiplicador": row[5]
            }
            for row in cursor.fetchall()
        ]
        conn.close()
        return entradas
    except Exception as e:
        print(f"❌ Erro ao obter histórico de entradas: {e}")
        return []

def obter_saldo():
    global driver, iframe_externo, iframe_interno
    try:
        driver.switch_to.default_content()
        saldo_element = WebDriverWait(driver, 20).until(
            EC.presence_of_element_located((By.XPATH, '//span[contains(@class, "balance") or contains(text(), "Kz")]'))
        )
        saldo = saldo_element.text.strip()
        print(f"Saldo capturado: {saldo}")
        driver.switch_to.frame(iframe_externo)
        driver.switch_to.frame(iframe_interno)
        return saldo
    except Exception as e:
        print(f"Erro ao obter saldo: {e}")
        try:
            saldo_element = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, '//header//span[contains(text(), "Kz")]'))
            )
            saldo = saldo_element.text.strip()
            print(f"Saldo capturado (fallback): {saldo}")
            driver.switch_to.frame(iframe_externo)
            driver.switch_to.frame(iframe_interno)
            return saldo
        except Exception as e2:
            print(f"Erro no fallback: {e2}")
            driver.switch_to.frame(iframe_externo)
            driver.switch_to.frame(iframe_interno)
            return "N/A"

def generate_ohlc(data, group_size=5):
    ohlc_data = []
    num_groups = len(data) // group_size
    for i in range(num_groups):
        chunk = data[i*group_size:(i+1)*group_size]
        open_ = chunk[0]
        high = max(chunk)
        low = min(chunk)
        close = chunk[-1]
        ohlc_data.append((open_, high, low, close))
    return ohlc_data

def on_mouse_wheel(event, ax, canvas):
    if not ax:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    xlim = ax.get_xlim()
    ylim = ax.get_ylim()
    zoom_factor = 1.2 if event.delta > 0 else 1 / 1.2
    new_xlim = [x - (x - xlim[0]) * zoom_factor, x + (xlim[1] - x) * zoom_factor]
    new_ylim = [y - (y - ylim[0]) * zoom_factor, y + (ylim[1] - y) * zoom_factor]
    ax.set_xlim(new_xlim)
    ax.set_ylim(new_ylim)
    canvas.draw_idle()

def analisar_tendencia(rodadas, window=5):
    if len(rodadas) < window * 2:
        return "Insuficiente", "gray"

    medias = []
    for i in range(0, len(rodadas) - window + 1, window):
        bloco = rodadas[i:i + window]
        if len(bloco) == window:
            medias.append(sum(bloco) / window)

    if len(medias) < 2:
        return "Insuficiente", "gray"

    ultima_media = medias[-1]
    penultima_media = medias[-2]
    margem = 0.5

    if ultima_media > penultima_media + margem:
        return "Alta", "green"
    elif ultima_media < penultima_media - margem:
        return "Baixa", "red"
    else:
        return "Lateral", "yellow"

def analisar_velas_rosa(rodadas):
    if not rodadas:
        return "Nenhuma vela rosa", len(rodadas), "Baixa"

    indices_rosa = [i for i, x in enumerate(rodadas) if x >= 10.0]

    if not indices_rosa:
        return "Nenhuma vela rosa", len(rodadas), "Baixa"

    intervalos = []
    for i in range(1, len(indices_rosa)):
        intervalos.append(indices_rosa[i] - indices_rosa[i-1])

    intervalo_medio = sum(intervalos) / len(intervalos) if intervalos else len(rodadas)
    ultima_rosa = indices_rosa[0]
    distancia = ultima_rosa

    if distancia >= intervalo_medio:
        probabilidade = "Alta"
    elif distancia >= intervalo_medio * 0.5:
        probabilidade = "Média"
    else:
        probabilidade = "Baixa"

    return f"{distancia} rodadas atrás", intervalo_medio, probabilidade

def mostrar_grafico_detetive(canvas_frame, rodadas):
    for widget in canvas_frame.winfo_children():
        widget.destroy()
    if not rodadas or len(rodadas) < 5:
        label = tk.Label(canvas_frame, text="Aguardando mais rodadas para exibir o gráfico...", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    ohlc_data = generate_ohlc(rodadas)
    if not ohlc_data:
        label = tk.Label(canvas_frame, text="Sem dados suficientes para o gráfico.", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    fig, ax = plt.subplots(figsize=(8, 4))
    width = 0.4
    for i, (open_, high, low, close) in enumerate(ohlc_data):
        cor = 'green' if close >= open_ else 'red'
        ax.plot([i, i], [low, high], color='black', linewidth=1)
        ax.add_patch(Rectangle((i - width/2, min(open_, close)), width, abs(close - open_), color=cor))
        grupo = rodadas[i*5:(i+1)*5]
        voos_str = ", ".join([f"{v:.2f}" for v in grupo])
        ax.text(i + 0.1, high + 0.5, voos_str, fontsize=8, rotation=45, color='blue')
    ax.set_xticks(range(len(ohlc_data)))
    ax.set_title("Modo Detetive - Gráfico Candlestick com Multiplicadores")
    ax.set_xlabel("Grupo de Rodadas")
    ax.set_ylabel("Multiplicador (x)")
    ax.grid(True)
    canvas = FigureCanvasTkAgg(fig, master=canvas_frame)
    canvas.draw()
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
    toolbar = NavigationToolbar2Tk(canvas, canvas_frame)
    toolbar.update()
    toolbar.pack(side=tk.BOTTOM, fill=tk.X)
    def mouse_wheel_event(event):
        on_mouse_wheel(event, ax, canvas)
    canvas.mpl_connect('scroll_event', mouse_wheel_event)

def mostrar_grafico_analista(canvas_frame, rodadas):
    for widget in canvas_frame.winfo_children():
        widget.destroy()
    if not rodadas or len(rodadas) < 5:
        label = tk.Label(canvas_frame, text="Aguardando mais rodadas para exibir o gráfico...", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    ohlc_data = generate_ohlc(rodadas)
    if not ohlc_data:
        label = tk.Label(canvas_frame, text="Sem dados suficientes para o gráfico.", font=("Arial", 12), fg="white", bg="#1e1e1e")
        label.pack(expand=True, fill=tk.BOTH)
        return
    dates = pd.date_range('2025-01-01', periods=len(ohlc_data))
    df = pd.DataFrame(ohlc_data, columns=["Open", "High", "Low", "Close"], index=dates)
    mc = mpf.make_marketcolors(up='green', down='red', inherit=True)
    s = mpf.make_mpf_style(marketcolors=mc)
    fig = plt.figure(figsize=(8, 4))
    ax = fig.add_subplot(111)
    mpf.plot(df, type='candle', style=s, title="Modo Analista - Gráfico Candlestick", ylabel='Multiplicador (x)', ax=ax, returnfig=True)
    canvas = FigureCanvasTkAgg(fig, master=canvas_frame)
    canvas.draw()
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
    toolbar = NavigationToolbar2Tk(canvas, canvas_frame)
    toolbar.update()
    toolbar.pack(side=tk.BOTTOM, fill=tk.X)
    def mouse_wheel_event(event):
        on_mouse_wheel(event, ax, canvas)
    canvas.mpl_connect('scroll_event', mouse_wheel_event)

def update_stats(period, frame, stats_label):
    try:
        if period not in ["Diário", "Semanal", "Mensal", "Anual"]:
            print(f"⚠️ Período inválido: {period}")
            return
        vitorias, derrotas, lucro, perdas = obter_estatisticas(period)
        lucro = float(lucro) if lucro is not None else 0.0
        perdas = float(perdas) if perdas is not None else 0.0
        if stats_label and hasattr(stats_label, 'config'):
            stats_label.config(text=f"Ganhos: {vitorias} | Perdas: {derrotas} | Lucro: Kz {lucro:.2f} | Perdas: Kz {perdas:.2f}")
        else:
            print(f"⚠️ stats_label inválido para período {period}")
    except Exception as e:
        print(f"❌ Erro ao atualizar estatísticas para {period}: {e}")

def configurar_navegacao():
    global iframe_externo, iframe_interno, driver
    print("📢 Iniciando configuração de navegação...")

    try:
        # Inicializar o WebDriver
        gecko_path = GeckoDriverManager().install()
        print(f"✅ geckodriver instalado em: {gecko_path}")
        webdriver_service = Service(gecko_path, log_path="geckodriver.log")
        driver = webdriver.Firefox(service=webdriver_service, options=options)
        driver.implicitly_wait(10)
        print("✅ Firefox WebDriver iniciado com sucesso")

        # Acessar a página inicial
        print("📢 Navegando para o site...")
        driver.get("https://www.bantubet.co.ao/pt/games")
        time.sleep(15)
        driver.refresh()
        print("✅ Página inicial carregada e atualizada.")

        # Aguardar e clicar no botão de login
        print("📢 Aguardando botão de login...")
        login_button = WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "#root > div.layout-header-holder-bc > header > div.hdr-main-content-bc > div.hdr-user-bc > button.btn.s-small.sign-in"))
        )
        time.sleep(5)
        login_button.click()
        print("✅ Botão de login clicado.")

        # Preencher campos de login
        print("📢 Preenchendo campos de login...")
        phone_input = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="root"]/div[6]/div/div/div/div/div/div[2]/form/div[1]/div[3]/div/label/input'))
        )
        phone_input.send_keys("923630632")
        time.sleep(2)
        password_input = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="root"]/div[6]/div/div/div/div/div/div[2]/form/div[1]/div[4]/div/label/input'))
        )
        password_input.send_keys("Ag9327777771317")
        time.sleep(4)
        submit_button = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="root"]/div[6]/div/div/div/div/div/div[2]/form/div[1]/div[6]/div/button'))
        )
        submit_button.click()
        print("📢 Login enviado, aguardando redirecionamento...")
        time.sleep(10)

        # Verificar login
        try:
            WebDriverWait(driver, 30).until(
                EC.presence_of_element_located((By.XPATH, '//span[contains(@class, "balance") or contains(text(), "Kz")]'))
            )
            print("✅ Login bem-sucedido! Saldo visível.")
        except Exception as e:
            print(f"❌ Falha ao verificar login: {e}")
            raise Exception("Login não foi bem-sucedido. Verifique as credenciais ou a página de login.")

        # Acessar a página do jogo Aviator
        print("📢 Acessando página do jogo Aviator...")
        driver.get("https://www.bantubet.co.ao/pt/games?openGames=806666-real&gameNames=Aviator")
        time.sleep(15)

        # Localizar iframe externo
        print("📢 Localizando iframe externo...")
        iframe_externo = WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="root"]/div[3]/div[1]/div[1]/div/iframe'))
        )
        driver.switch_to.frame(iframe_externo)
        print("✅ Iframe externo encontrado e acessado.")
        time.sleep(10)

        # Localizar iframe interno
        print("📢 Localizando iframe interno...")
        iframe_interno = WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="gameFrame"]'))
        )
        driver.switch_to.frame(iframe_interno)
        print("✅ Iframe interno encontrado e acessado.")
        time.sleep(10)

        # Verificar se o jogo carregou
        try:
            WebDriverWait(driver, 30).until(
                EC.presence_of_element_located((By.CLASS_NAME, 'result-history'))
            )
            print("✅ Jogo Aviator carregado com sucesso. Histórico visível.")
    